(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
(factory((global['react-auth-wrapper'] = {}),global.React));
}(this, (function (exports,React) { 'use strict';

var React__default = 'default' in React ? React['default'] : React;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var hoistNonReactStatics = createCommonjsModule(function (module, exports) {
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
(function (global, factory) {
    module.exports = factory();
}(commonjsGlobal, (function () {
    
    var REACT_STATICS = {
        childContextTypes: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
    };
    
    var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
    };
    
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = getPrototypeOf && getPrototypeOf(Object);
    
    return function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
            
            if (objectPrototype) {
                var inheritedComponent = getPrototypeOf(sourceComponent);
                if (inheritedComponent && inheritedComponent !== objectPrototype) {
                    hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                }
            }
            
            var keys = getOwnPropertyNames(sourceComponent);
            
            if (getOwnPropertySymbols) {
                keys = keys.concat(getOwnPropertySymbols(sourceComponent));
            }
            
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                    var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                    try { // Avoid failures from read-only properties
                        defineProperty(targetComponent, key, descriptor);
                    } catch (e) {}
                }
            }
            
            return targetComponent;
        }
        
        return targetComponent;
    };
})));
});

function encode(key, value) {
  var keyOnly = value == null || typeof value !== 'string' && typeof value !== 'number' && !Array.isArray(value);
  return keyOnly ? encodeURIComponent(key) : [encodeURIComponent(key), '=', encodeURIComponent(value)].join('');
}

function parse(strRaw, key) {
  if (typeof key !== 'string' || !key || typeof strRaw !== 'string' || !strRaw) {
    return '';
  }

  var decodedVal = strRaw.split('&').filter(function (kv) {
    return kv.split('=')[0] === key && kv.split('=')[1];
  }).map(function (kv) {
    return decodeURIComponent(kv.split('=')[1]);
  })[0];

  try {
    if (/({|}|\[|\])/.test(decodedVal)) {
      return JSON.parse(decodedVal);
    }
  } catch (error) {// Failed to parse json
  }

  return decodedVal;
}

function parseQs(qsRaw) {
  if (typeof qsRaw !== 'string' || !qsRaw) {
    return {};
  }

  return qsRaw.split('&').filter(function (kv) {
    return kv.split('=')[1];
  }).reduce(function (acc, kv) {
    var _objectSpread2;

    return _objectSpread({}, acc, (_objectSpread2 = {}, _objectSpread2[kv.split('=')[0]] = decodeURIComponent(kv.split('=')[1]), _objectSpread2));
  }, {});
}

function stringify(obj) {
  if (!obj) return '';
  return Object.keys(obj).map(function (key) {
    var value = obj[key];
    if (value === undefined) return '';
    if (value === null || typeof value === 'string' && !value) return encodeURIComponent(key);

    if (Array.isArray(value)) {
      var result = [];
      value.filter(function (v) {
        return v !== 'undefined';
      }).forEach(function (val) {
        result.push(encode(key, val, result.length));
      });
      return result.join('&');
    }

    return encode(key, value);
  }).filter(Boolean).join('&');
}

function parseUrl(url) {
  var hash = '';
  var search = '';
  var pathname = '';
  var href = (url || '').trim();
  var protocolIndex = href.indexOf('://');
  var withoutProtocol = protocolIndex !== -1 ? href.substring(protocolIndex + 3) : href; // eslint-disable-next-line

  var _withoutProtocol$spli = withoutProtocol.split('/').filter(Boolean),
      host = _withoutProtocol$spli[0],
      parts = _withoutProtocol$spli.slice(1);

  pathname = "/" + (parts.join('/') || host);

  if (pathname.split('#').length === 2) {
    var _pathname$split = pathname.split('#');

    pathname = _pathname$split[0];
    hash = _pathname$split[1];
  }

  if (pathname.split('?').length === 2) {
    var _pathname$split2 = pathname.split('?');

    pathname = _pathname$split2[0];
    search = _pathname$split2[1];
  }

  var query = parseQs(search) || {};
  return {
    hash: hash,
    host: host,
    query: query,
    search: search ? "?" + search : search,
    href: href.replace(/\/$/, ''),
    pathname: pathname.replace(/\/$/, '')
  };
}

function getFullRedirectPath(redirectQueryParamName, redirectPath, allowRedirectBack, location) {
  var _ref;

  if (!redirectPath) return ''; // eslint-disable-next-line no-undef

  var redirectLoc = parseUrl(redirectPath);
  var qsRaw = location ? "" + (location.pathname || '') + (location.search || '') + (location.hash || '') : '';
  var query = allowRedirectBack && qsRaw ? (_ref = {}, _ref[redirectQueryParamName || 'redirect'] = qsRaw, _ref) : {};
  var qs = stringify(_objectSpread({}, query, redirectLoc.query));
  return "" + (redirectLoc.pathname || '') + (redirectLoc.hash || '') + (qs ? "?" + qs : '');
}

function validateStringOrFunction(val, name) {
  if (name === void 0) {
    name = 'prop';
  }

  if (typeof val === 'string') {
    return function (p) {
      return p && p[val];
    };
  } else if (typeof val === 'function') {
    return val;
  } else {
    throw new Error(name + " must be either a string or a function");
  }
}

function validateBoolOrFunction(val, name) {
  if (name === void 0) {
    name = 'prop';
  }

  if (typeof val === 'boolean') {
    return function () {
      return val;
    };
  } else if (typeof val === 'function') {
    return val;
  } else {
    throw new Error(name + " must be either a bool or a function");
  }
}

var defaults = {
  authenticatedSelector: function authenticatedSelector(p) {
    return Boolean(p.isAuthenticated);
  },
  authenticatingSelector: function authenticatingSelector(p) {
    return Boolean(p.isAuthenticating);
  },
  AuthenticatingComponent: function AuthenticatingComponent() {
    return null;
  },
  // dont render anything while authenticating
  FailureComponent: function FailureComponent() {
    return null;
  },
  // dont render anything on failure of the predicate
  wrapperDisplayName: 'AuthWrapper'
  /**
   * A simple wrapper to any component that will only display the component if the user is in an authenticated state.
   * It will look for props injected into the component to determine whether to display either:
   *   - A Failure Component (when the `authenticatedSelector` returns `false`)
   *   - An Authenticating/Pending Component (when `authenticatingSelector` returns `true` and `authenticatedSelector` also returns `false`)
   *   - Your actual Component (when the `authenticatedSelector` returns `true`)
   * If the optional components are not provided `null` will be rendered/returned when in those states.
   *
   * @func
   * @sig {k: v} -> (Component -> ({k: v} -> Component))
   * @param {Function|String} args.authenticatedSelector A prop name OR a selector function
   * that will find the prop injected into the component that identifies whether the user is authenticated or not
   * (defaults to look for a prop named `isAuthenticated`)
   * @param {Function|String} args.authenticatingSelector A prop name OR a selector function
   * that will find the prop injected into the component that identifies whether the user authentication
   * is in-progress or not (defaults to look for a prop named `isAuthenticating`)
   * @param {Function} args.AuthenticatingComponent An optional component that would be
   * displaying while authentication is in-progress (defaults to an empty Component that returns `null`)
   * @param {Function} args.FailureComponent An optional component that would be diplayed
   * when authentication fails (defaults to a Component Component that returns `null`)
   * @param {String} args.wrapperDisplayName An optional display name to give to
   * the wrapper component (defaults to just 'AuthWrapper')
   * @returns {Function} A function that is ready to receive a Component to decorate
   */

};

function withAuth(args) {
  if (args === void 0) {
    args = {};
  }

  var _defaults$args = _objectSpread({}, defaults, args),
      FailureComponent = _defaults$args.FailureComponent,
      wrapperDisplayName = _defaults$args.wrapperDisplayName,
      authenticatedSelector = _defaults$args.authenticatedSelector,
      authenticatingSelector = _defaults$args.authenticatingSelector,
      AuthenticatingComponent = _defaults$args.AuthenticatingComponent;

  var getAuthenticated = validateStringOrFunction(authenticatedSelector, 'authenticatedSelector');
  var getAuthenticating = validateStringOrFunction(authenticatingSelector, 'authenticatingSelector'); // Wraps the component that needs the auth enforcement

  function wrapComponent(DecoratedComponent) {
    var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

    var AuthWrapper = function AuthWrapper(props) {
      var isAuthenticated = getAuthenticated(props);
      var isAuthenticating = getAuthenticating(props);

      if (isAuthenticated) {
        return React__default.createElement(DecoratedComponent, props);
      } else if (isAuthenticating) {
        return React__default.createElement(AuthenticatingComponent, props);
      } else {
        return React__default.createElement(FailureComponent, props);
      }
    };

    AuthWrapper.displayName = wrapperDisplayName + "(" + displayName + ")";
    return hoistNonReactStatics(AuthWrapper, DecoratedComponent);
  }

  return wrapComponent;
}

var Redirect =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose(Redirect, _PureComponent);

  function Redirect() {
    return _PureComponent.apply(this, arguments) || this;
  }

  var _proto = Redirect.prototype;

  _proto.render = function render() {
    var _this$props = this.props,
        redirectPath = _this$props.redirectPath,
        location = _this$props.location,
        history = _this$props.history;

    if (redirectPath) {
      if (history && typeof history.push === 'function') {
        history.push(redirectPath);
      } else if (location && typeof location.replace === 'function') {
        location.replace(redirectPath);
      } else if (typeof window !== 'undefined') {
        // eslint-disable-next-line no-undef
        window.location.replace(redirectPath);
      }
    }

    return null;
  };

  return Redirect;
}(React.PureComponent);

var defaults$1 = {
  authenticatedSelector: function authenticatedSelector(p) {
    return Boolean(p.isAuthenticated);
  },
  authenticatingSelector: function authenticatingSelector(p) {
    return Boolean(p.isAuthenticating);
  },
  allowRedirectBack: true,
  FailureComponent: Redirect,
  wrapperDisplayName: 'AuthRedirectWrapper',
  redirectQueryParamName: 'redirect'
};

function getLocation(props) {
  if (props === void 0) {
    props = {};
  }

  return props.location || typeof window !== 'undefined' && window.location || {};
}

function createRedirectWrapper(wrapper) {
  function withRedirect(args) {
    if (args === void 0) {
      args = {};
    }

    var allArgs = _objectSpread({}, defaults$1, args);

    var redirectPath = allArgs.redirectPath,
        FailureComponent = allArgs.FailureComponent,
        allowRedirectBack = allArgs.allowRedirectBack,
        authenticatedSelector = allArgs.authenticatedSelector,
        authenticatingSelector = allArgs.authenticatingSelector,
        _allArgs$redirectQuer = allArgs.redirectQueryParamName,
        redirectQueryParamName = _allArgs$redirectQuer === void 0 ? 'redirect' : _allArgs$redirectQuer;
    var allowRedirectBackFn = validateBoolOrFunction(allowRedirectBack, 'allowRedirectBack');
    var getAuthenticated = validateStringOrFunction(authenticatedSelector, 'authenticatedSelector');
    var getAuthenticating = validateStringOrFunction(authenticatingSelector, 'authenticatingSelector');

    var EnhancedFailureComponent = function EnhancedFailureComponent(props) {
      return React__default.createElement(FailureComponent, _extends({}, props, {
        redirectPath: parse(getLocation(props).search, redirectQueryParamName) || getFullRedirectPath(redirectQueryParamName, props.redirectPath || redirectPath, allowRedirectBackFn(props), getLocation(props))
      }));
    };

    return function (DecoratedComponent) {
      var AuthWrapped = wrapper(_objectSpread({}, allArgs, {
        FailureComponent: EnhancedFailureComponent
      }))(DecoratedComponent);
      return function (props) {
        return React__default.createElement(AuthWrapped, _extends({}, props, {
          isAuthenticated: getAuthenticated(props),
          isAuthenticating: getAuthenticating(props)
        }));
      };
    };
  }

  return withRedirect;
}

/**
 * A simple wrapper to any component that will only display the component if the user is in an authenticated state.
 * Unlike the `withAuth` higher-order component, this one will default to a given route or relative URL when authentication fails.
 * It will look for props injected into the component to determine whether to display either:
 *   - A Failure Component (when the `authenticatedSelector` returns `false`, but will default to render a redirect component)
 *   - An Authenticating/Pending Component (when `authenticatingSelector` returns `true` and `authenticatedSelector` also returns `false`)
 *   - Your actual Component (when the `authenticatedSelector` returns `true`)
 *
 * @func
 * @sig {k: v} -> (Component -> ({k: v} -> Component))
 * @param {Function|String} args.authenticatedSelector A prop name OR a selector function
 * that will find the prop injected into the component that identifies whether the user is authenticated or not
 * (defaults to look for a prop named `isAuthenticated`)
 * @param {Function|String} args.authenticatingSelector A prop name OR a selector function
 * that will find the prop injected into the component that identifies whether the user authentication
 * is in-progress or not (defaults to look for a prop named `isAuthenticating`)
 * @param {Function|String} args.redirectPath A prop name OR a selector function
 * that will find the prop injected into the component that identifies the
 * route or relative URL to send the user to when authentication fails
 * @param {Function} args.AuthenticatingComponent An optional component that would be
 * displaying while authentication is in-progress (defaults to an empty
 * Component that returns `null`)
 * @param {Boolean} args.allowRedirectBack Whether or not to redirect back to
 * the original location after authentication completes successfully
 * @param {Function} args.FailureComponent An optional component that would be diplayed
 * when authentication fails (defaults to a Component Component that returns `null`, _but_
 * redirects to whatever it finds on the `redirectPath`)
 * @param {String} args.wrapperDisplayName An optional display name to give to
 * the wrapper component (defaults to just 'AuthWrapper')
 * @param {String} args.redirectQueryParamName An optional prop name to identify
 * the route/relative-URL from the component's injected props
 * @returns {Function} A function that is ready to receive a Component to decorate
 */

var withAuthAndRedirect = createRedirectWrapper(withAuth);

var defaults$2 = {
  authenticatingSelector: function authenticatingSelector(contextProps) {
    return contextProps.isAuthenticating;
  },
  authenticatedSelector: function authenticatedSelector(contextProps) {
    return contextProps.isAuthenticated;
  }
  /**
   * A simple wrapper to any component that will only display the component if the user is in an authenticated state.
   * Unlike the `withAuth` higher-order component, this one is expecting a [Context Consumer](https://reactjs.org/docs/context.html#contextconsumer)
   * to be provided, and it will use the props provided to the consumer to apply the authenticated/authenticating selectors.
   * It will look for props injected into the component to determine whether to display either:
   *   - A Failure Component (when the `authenticatedSelector` returns `false`)
   *   - An Authenticating/Pending Component (when `authenticatingSelector` returns `true` and `authenticatedSelector` also returns `false`)
   *   - Your actual Component (when the `authenticatedSelector` returns `true`)
   * If the optional components are not provided `null` will be rendered/returned when in those states.
   *
   * @func
   * @sig {k: v} -> (Component -> ({k: v} -> Component))
   * @param {Function|String} args.authenticatedSelector A prop name OR a selector function
   * that will find the prop injected into the component that identifies whether the user is authenticated or not
   * (defaults to look for a prop named `isAuthenticated`)
   * @param {Function|String} args.authenticatingSelector A prop name OR a selector function
   * that will find the prop injected into the component that identifies whether the user authentication
   * is in-progress or not (defaults to look for a prop named `isAuthenticating`)
   * @param {Function} args.ContextConsumer An instance of a `.Consumer` from the context object that
   * [React.createContext()](https://reactjs.org/docs/context.html#reactcreatecontext) returns
   * @param {Function} args.AuthenticatingComponent An optional component that would be
   * displaying while authentication is in-progress (defaults to an empty Component that returns `null`)
   * @param {Function} args.FailureComponent An optional component that would be diplayed
   * when authentication fails (defaults to a Component Component that returns `null`)
   * @param {String} args.wrapperDisplayName An optional display name to give to
   * the wrapper component (defaults to just 'AuthWrapper')
   * @returns {Function} A function that is ready to receive a Component to decorate
   */

};

function withAuthFromContext(args) {
  if (args === void 0) {
    args = {};
  }

  var _defaults$args = _objectSpread({}, defaults$2, args),
      ContextConsumer = _defaults$args.ContextConsumer,
      authenticatedSelector = _defaults$args.authenticatedSelector,
      authenticatingSelector = _defaults$args.authenticatingSelector,
      restOfArgs = _objectWithoutPropertiesLoose(_defaults$args, ["ContextConsumer", "authenticatedSelector", "authenticatingSelector"]);

  var getAuthenticated = validateStringOrFunction(authenticatedSelector, 'authenticatedSelector');
  var getAuthenticating = validateStringOrFunction(authenticatingSelector, 'authenticatingSelector');
  return function (DecoratedComponent) {
    var AuthWrappedComponent = withAuth(restOfArgs)(DecoratedComponent);
    return function (props) {
      return React__default.createElement(ContextConsumer, props, function (contextProps) {
        return React__default.createElement(AuthWrappedComponent, _extends({}, props, {
          isAuthenticated: getAuthenticated(contextProps),
          isAuthenticating: getAuthenticating(contextProps)
        }));
      });
    };
  };
}

/**
 * A simple wrapper to any component that will only display the component if the user is in an authenticated state.
 * Unlike the `withAuth` higher-order component, this one will default to a given route or relative URL when authentication fails.
 * Additionally, it is driven by a context consumer component (one of the props returned in the output of [React.createContext()](https://reactjs.org/docs/context.html#reactcreatecontext)).
 * It will look for props injected into the component to determine whether to display either:
 *   - A Failure Component (when the `authenticatedSelector` returns `false`, but will default to render a redirect component)
 *   - An Authenticating/Pending Component (when `authenticatingSelector` returns `true` and `authenticatedSelector` also returns `false`)
 *   - Your actual Component (when the `authenticatedSelector` returns `true`)
 *
 * @func
 * @sig {k: v} -> (Component -> ({k: v} -> Component))
 * @param {Function|String} args.authenticatedSelector A prop name OR a selector function
 * that will find the prop injected into the component that identifies whether the user is authenticated or not
 * (defaults to look for a prop named `isAuthenticated`)
 * @param {Function|String} args.authenticatingSelector A prop name OR a selector function
 * that will find the prop injected into the component that identifies whether the user authentication
 * is in-progress or not (defaults to look for a prop named `isAuthenticating`)
 * @param {Function|String} args.redirectPath A prop name OR a selector function
 * that will find the prop injected into the component that identifies the
 * route or relative URL to send the user to when authentication fails
 * @param {Function} args.AuthenticatingComponent An optional component that would be
 * displaying while authentication is in-progress (defaults to an empty
 * Component that returns `null`)
 * @param {Function} args.ContextConsumer An instance of a `.Consumer` from the context object that
 * [React.createContext()](https://reactjs.org/docs/context.html#reactcreatecontext) returns
 * @param {Boolean} args.allowRedirectBack Whether or not to redirect back to
 * the original location after authentication completes successfully
 * @param {Function} args.FailureComponent An optional component that would be diplayed
 * when authentication fails (defaults to a Component Component that returns `null`, _but_
 * redirects to whatever it finds on the `redirectPath`)
 * @param {String} args.wrapperDisplayName An optional display name to give to
 * the wrapper component (defaults to just 'AuthWrapper')
 * @param {String} args.redirectQueryParamName An optional prop name to identify
 * the route/relative-URL from the component's injected props
 * @returns {Function} A function that is ready to receive a Component to decorate
 */

var withAuthFromContextAndRedirect = createRedirectWrapper(withAuthFromContext);

exports.withAuth = withAuth;
exports.withAuthAndRedirect = withAuthAndRedirect;
exports.withAuthFromContext = withAuthFromContext;
exports.withAuthFromContextAndRedirect = withAuthFromContextAndRedirect;

Object.defineProperty(exports, '__esModule', { value: true });

})));
