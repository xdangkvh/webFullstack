{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { SKELETON_TYPE, TYPE } from './types';\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton } from '@formatjs/icu-skeleton-parser';\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\" + SPACE_SEPARATOR_REGEX.source + \"*\");\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(SPACE_SEPARATOR_REGEX.source + \"*$\");\n\nfunction createLocation(start, end) {\n  return {\n    start: start,\n    end: end\n  };\n} // #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\n\n\nvar hasNativeStartsWith = !!String.prototype.startsWith;\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function (n) {\n  return typeof n === 'number' && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 0x1fffffffffffff;\n}; // IE11 does not support y and u.\n\nvar REGEX_SUPPORTS_U_AND_Y = true;\n\ntry {\n  var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n  /**\r\n   * legacy Edge or Xbox One browser\r\n   * Unicode flag support: supported\r\n   * Pattern_Syntax support: not supported\r\n   * See https://github.com/formatjs/formatjs/issues/2822\r\n   */\n\n  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\n} catch (_) {\n  REGEX_SUPPORTS_U_AND_Y = false;\n}\n\nvar startsWith = hasNativeStartsWith ? // Native\nfunction startsWith(s, search, position) {\n  return s.startsWith(search, position);\n} : // For IE11\nfunction startsWith(s, search, position) {\n  return s.slice(position, position + search.length) === search;\n};\nvar fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : // IE11\nfunction fromCodePoint() {\n  var codePoints = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    codePoints[_i] = arguments[_i];\n  }\n\n  var elements = '';\n  var length = codePoints.length;\n  var i = 0;\n  var code;\n\n  while (length > i) {\n    code = codePoints[i++];\n    if (code > 0x10ffff) throw RangeError(code + ' is not a valid code point');\n    elements += code < 0x10000 ? String.fromCharCode(code) : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00);\n  }\n\n  return elements;\n};\nvar fromEntries = // native\nhasNativeFromEntries ? Object.fromEntries : // Ponyfill\nfunction fromEntries(entries) {\n  var obj = {};\n\n  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n    var _a = entries_1[_i],\n        k = _a[0],\n        v = _a[1];\n    obj[k] = v;\n  }\n\n  return obj;\n};\nvar codePointAt = hasNativeCodePointAt ? // Native\nfunction codePointAt(s, index) {\n  return s.codePointAt(index);\n} : // IE 11\nfunction codePointAt(s, index) {\n  var size = s.length;\n\n  if (index < 0 || index >= size) {\n    return undefined;\n  }\n\n  var first = s.charCodeAt(index);\n  var second;\n  return first < 0xd800 || first > 0xdbff || index + 1 === size || (second = s.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? first : (first - 0xd800 << 10) + (second - 0xdc00) + 0x10000;\n};\nvar trimStart = hasTrimStart ? // Native\nfunction trimStart(s) {\n  return s.trimStart();\n} : // Ponyfill\nfunction trimStart(s) {\n  return s.replace(SPACE_SEPARATOR_START_REGEX, '');\n};\nvar trimEnd = hasTrimEnd ? // Native\nfunction trimEnd(s) {\n  return s.trimEnd();\n} : // Ponyfill\nfunction trimEnd(s) {\n  return s.replace(SPACE_SEPARATOR_END_REGEX, '');\n}; // Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\n\nfunction RE(s, flag) {\n  return new RegExp(s, flag);\n} // #endregion\n\n\nvar matchIdentifierAtIndex;\n\nif (REGEX_SUPPORTS_U_AND_Y) {\n  // Native\n  var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var _a;\n\n    IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n    var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n    return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n  };\n} else {\n  // IE11\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var match = [];\n\n    while (true) {\n      var c = codePointAt(s, index);\n\n      if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n        break;\n      }\n\n      match.push(c);\n      index += c >= 0x10000 ? 2 : 1;\n    }\n\n    return fromCodePoint.apply(void 0, match);\n  };\n}\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(message, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.message = message;\n    this.position = {\n      offset: 0,\n      line: 1,\n      column: 1\n    };\n    this.ignoreTag = !!options.ignoreTag;\n    this.requiresOtherClause = !!options.requiresOtherClause;\n    this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n  }\n\n  Parser.prototype.parse = function () {\n    if (this.offset() !== 0) {\n      throw Error('parser can only be used once');\n    }\n\n    return this.parseMessage(0, '', false);\n  };\n\n  Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n    var elements = [];\n\n    while (!this.isEOF()) {\n      var char = this.char();\n\n      if (char === 123\n      /* `{` */\n      ) {\n          var result = this.parseArgument(nestingLevel, expectingCloseTag);\n\n          if (result.err) {\n            return result;\n          }\n\n          elements.push(result.val);\n        } else if (char === 125\n      /* `}` */\n      && nestingLevel > 0) {\n        break;\n      } else if (char === 35\n      /* `#` */\n      && (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n        var position = this.clonePosition();\n        this.bump();\n        elements.push({\n          type: TYPE.pound,\n          location: createLocation(position, this.clonePosition())\n        });\n      } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && this.peek() === 47 // char code for '/'\n      ) {\n          if (expectingCloseTag) {\n            break;\n          } else {\n            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n          }\n        } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && _isAlpha(this.peek() || 0)) {\n        var result = this.parseTag(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      } else {\n        var result = this.parseLiteral(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      }\n    }\n\n    return {\n      val: elements,\n      err: null\n    };\n  };\n  /**\r\n   * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\r\n   * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\r\n   * are accepted:\r\n   *\r\n   * ```\r\n   * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\r\n   * tagName ::= [a-z] (PENChar)*\r\n   * PENChar ::=\r\n   *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\r\n   *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\r\n   *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n   * ```\r\n   *\r\n   * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\r\n   * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\r\n   * since other tag-based engines like React allow it\r\n   */\n\n\n  Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n    var startPosition = this.clonePosition();\n    this.bump(); // `<`\n\n    var tagName = this.parseTagName();\n    this.bumpSpace();\n\n    if (this.bumpIf('/>')) {\n      // Self closing tag\n      return {\n        val: {\n          type: TYPE.literal,\n          value: \"<\" + tagName + \"/>\",\n          location: createLocation(startPosition, this.clonePosition())\n        },\n        err: null\n      };\n    } else if (this.bumpIf('>')) {\n      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n\n      if (childrenResult.err) {\n        return childrenResult;\n      }\n\n      var children = childrenResult.val; // Expecting a close tag\n\n      var endTagStartPosition = this.clonePosition();\n\n      if (this.bumpIf('</')) {\n        if (this.isEOF() || !_isAlpha(this.char())) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        var closingTagNameStartPosition = this.clonePosition();\n        var closingTagName = this.parseTagName();\n\n        if (tagName !== closingTagName) {\n          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n        }\n\n        this.bumpSpace();\n\n        if (!this.bumpIf('>')) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        return {\n          val: {\n            type: TYPE.tag,\n            value: tagName,\n            children: children,\n            location: createLocation(startPosition, this.clonePosition())\n          },\n          err: null\n        };\n      } else {\n        return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n      }\n    } else {\n      return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n    }\n  };\n  /**\r\n   * This method assumes that the caller has peeked ahead for the first tag character.\r\n   */\n\n\n  Parser.prototype.parseTagName = function () {\n    var startOffset = this.offset();\n    this.bump(); // the first tag name character\n\n    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n      this.bump();\n    }\n\n    return this.message.slice(startOffset, this.offset());\n  };\n\n  Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n    var start = this.clonePosition();\n    var value = '';\n\n    while (true) {\n      var parseQuoteResult = this.tryParseQuote(parentArgType);\n\n      if (parseQuoteResult) {\n        value += parseQuoteResult;\n        continue;\n      }\n\n      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n\n      if (parseUnquotedResult) {\n        value += parseUnquotedResult;\n        continue;\n      }\n\n      var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n\n      if (parseLeftAngleResult) {\n        value += parseLeftAngleResult;\n        continue;\n      }\n\n      break;\n    }\n\n    var location = createLocation(start, this.clonePosition());\n    return {\n      val: {\n        type: TYPE.literal,\n        value: value,\n        location: location\n      },\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseLeftAngleBracket = function () {\n    if (!this.isEOF() && this.char() === 60\n    /* `<` */\n    && (this.ignoreTag || // If at the opening tag or closing tag position, bail.\n    !_isAlphaOrSlash(this.peek() || 0))) {\n      this.bump(); // `<`\n\n      return '<';\n    }\n\n    return null;\n  };\n  /**\r\n   * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\r\n   * a character that requires quoting (that is, \"only where needed\"), and works the same in\r\n   * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\r\n   */\n\n\n  Parser.prototype.tryParseQuote = function (parentArgType) {\n    if (this.isEOF() || this.char() !== 39\n    /* `'` */\n    ) {\n        return null;\n      } // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n    // Check if is valid escaped character\n\n\n    switch (this.peek()) {\n      case 39\n      /* `'` */\n      :\n        // double quote, should return as a single quote.\n        this.bump();\n        this.bump();\n        return \"'\";\n      // '{', '<', '>', '}'\n\n      case 123:\n      case 60:\n      case 62:\n      case 125:\n        break;\n\n      case 35:\n        // '#'\n        if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n          break;\n        }\n\n        return null;\n\n      default:\n        return null;\n    }\n\n    this.bump(); // apostrophe\n\n    var codePoints = [this.char()]; // escaped char\n\n    this.bump(); // read chars until the optional closing apostrophe is found\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch === 39\n      /* `'` */\n      ) {\n          if (this.peek() === 39\n          /* `'` */\n          ) {\n              codePoints.push(39); // Bump one more time because we need to skip 2 characters.\n\n              this.bump();\n            } else {\n            // Optional closing apostrophe.\n            this.bump();\n            break;\n          }\n        } else {\n        codePoints.push(ch);\n      }\n\n      this.bump();\n    }\n\n    return fromCodePoint.apply(void 0, codePoints);\n  };\n\n  Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var ch = this.char();\n\n    if (ch === 60\n    /* `<` */\n    || ch === 123\n    /* `{` */\n    || ch === 35\n    /* `#` */\n    && (parentArgType === 'plural' || parentArgType === 'selectordinal') || ch === 125\n    /* `}` */\n    && nestingLevel > 0) {\n      return null;\n    } else {\n      this.bump();\n      return fromCodePoint(ch);\n    }\n  };\n\n  Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n    var openingBracePosition = this.clonePosition();\n    this.bump(); // `{`\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    if (this.char() === 125\n    /* `}` */\n    ) {\n        this.bump();\n        return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n      } // argument name\n\n\n    var value = this.parseIdentifierIfPossible().value;\n\n    if (!value) {\n      return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    switch (this.char()) {\n      // Simple argument: `{name}`\n      case 125\n      /* `}` */\n      :\n        {\n          this.bump(); // `}`\n\n          return {\n            val: {\n              type: TYPE.argument,\n              // value does not include the opening and closing braces.\n              value: value,\n              location: createLocation(openingBracePosition, this.clonePosition())\n            },\n            err: null\n          };\n        }\n      // Argument with options: `{name, format, ...}`\n\n      case 44\n      /* `,` */\n      :\n        {\n          this.bump(); // `,`\n\n          this.bumpSpace();\n\n          if (this.isEOF()) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n          }\n\n          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n        }\n\n      default:\n        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n  };\n  /**\r\n   * Advance the parser until the end of the identifier, if it is currently on\r\n   * an identifier character. Return an empty string otherwise.\r\n   */\n\n\n  Parser.prototype.parseIdentifierIfPossible = function () {\n    var startingPosition = this.clonePosition();\n    var startOffset = this.offset();\n    var value = matchIdentifierAtIndex(this.message, startOffset);\n    var endOffset = startOffset + value.length;\n    this.bumpTo(endOffset);\n    var endPosition = this.clonePosition();\n    var location = createLocation(startingPosition, endPosition);\n    return {\n      value: value,\n      location: location\n    };\n  };\n\n  Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n    var _a; // Parse this range:\n    // {name, type, style}\n    //        ^---^\n\n\n    var typeStartPosition = this.clonePosition();\n    var argType = this.parseIdentifierIfPossible().value;\n    var typeEndPosition = this.clonePosition();\n\n    switch (argType) {\n      case '':\n        // Expecting a style string number, date, time, plural, selectordinal, or select.\n        return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n\n      case 'number':\n      case 'date':\n      case 'time':\n        {\n          // Parse this range:\n          // {name, number, style}\n          //              ^-------^\n          this.bumpSpace();\n          var styleAndLocation = null;\n\n          if (this.bumpIf(',')) {\n            this.bumpSpace();\n            var styleStartPosition = this.clonePosition();\n            var result = this.parseSimpleArgStyleIfPossible();\n\n            if (result.err) {\n              return result;\n            }\n\n            var style = trimEnd(result.val);\n\n            if (style.length === 0) {\n              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n            styleAndLocation = {\n              style: style,\n              styleLocation: styleLocation\n            };\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_1 = createLocation(openingBracePosition, this.clonePosition()); // Extract style or skeleton\n\n          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n            // Skeleton starts with `::`.\n            var skeleton = trimStart(styleAndLocation.style.slice(2));\n\n            if (argType === 'number') {\n              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n\n              if (result.err) {\n                return result;\n              }\n\n              return {\n                val: {\n                  type: TYPE.number,\n                  value: value,\n                  location: location_1,\n                  style: result.val\n                },\n                err: null\n              };\n            } else {\n              if (skeleton.length === 0) {\n                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n              }\n\n              var style = {\n                type: SKELETON_TYPE.dateTime,\n                pattern: skeleton,\n                location: styleAndLocation.styleLocation,\n                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(skeleton) : {}\n              };\n              var type = argType === 'date' ? TYPE.date : TYPE.time;\n              return {\n                val: {\n                  type: type,\n                  value: value,\n                  location: location_1,\n                  style: style\n                },\n                err: null\n              };\n            }\n          } // Regular style or no style.\n\n\n          return {\n            val: {\n              type: argType === 'number' ? TYPE.number : argType === 'date' ? TYPE.date : TYPE.time,\n              value: value,\n              location: location_1,\n              style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null\n            },\n            err: null\n          };\n        }\n\n      case 'plural':\n      case 'selectordinal':\n      case 'select':\n        {\n          // Parse this range:\n          // {name, plural, options}\n          //              ^---------^\n          var typeEndPosition_1 = this.clonePosition();\n          this.bumpSpace();\n\n          if (!this.bumpIf(',')) {\n            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\n          }\n\n          this.bumpSpace(); // Parse offset:\n          // {name, plural, offset:1, options}\n          //                ^-----^\n          //\n          // or the first option:\n          //\n          // {name, plural, one {...} other {...}}\n          //                ^--^\n\n          var identifierAndLocation = this.parseIdentifierIfPossible();\n          var pluralOffset = 0;\n\n          if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n            if (!this.bumpIf(':')) {\n              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            this.bumpSpace();\n            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n\n            if (result.err) {\n              return result;\n            } // Parse another identifier for option parsing\n\n\n            this.bumpSpace();\n            identifierAndLocation = this.parseIdentifierIfPossible();\n            pluralOffset = result.val;\n          }\n\n          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n\n          if (optionsResult.err) {\n            return optionsResult;\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_2 = createLocation(openingBracePosition, this.clonePosition());\n\n          if (argType === 'select') {\n            return {\n              val: {\n                type: TYPE.select,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                location: location_2\n              },\n              err: null\n            };\n          } else {\n            return {\n              val: {\n                type: TYPE.plural,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                offset: pluralOffset,\n                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                location: location_2\n              },\n              err: null\n            };\n          }\n        }\n\n      default:\n        return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n    }\n  };\n\n  Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n    // Parse: {value, number, ::currency/GBP }\n    //\n    if (this.isEOF() || this.char() !== 125\n    /* `}` */\n    ) {\n        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n      }\n\n    this.bump(); // `}`\n\n    return {\n      val: true,\n      err: null\n    };\n  };\n  /**\r\n   * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\r\n   */\n\n\n  Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n    var nestedBraces = 0;\n    var startPosition = this.clonePosition();\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      switch (ch) {\n        case 39\n        /* `'` */\n        :\n          {\n            // Treat apostrophe as quoting but include it in the style part.\n            // Find the end of the quoted literal text.\n            this.bump();\n            var apostrophePosition = this.clonePosition();\n\n            if (!this.bumpUntil(\"'\")) {\n              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n            }\n\n            this.bump();\n            break;\n          }\n\n        case 123\n        /* `{` */\n        :\n          {\n            nestedBraces += 1;\n            this.bump();\n            break;\n          }\n\n        case 125\n        /* `}` */\n        :\n          {\n            if (nestedBraces > 0) {\n              nestedBraces -= 1;\n            } else {\n              return {\n                val: this.message.slice(startPosition.offset, this.offset()),\n                err: null\n              };\n            }\n\n            break;\n          }\n\n        default:\n          this.bump();\n          break;\n      }\n    }\n\n    return {\n      val: this.message.slice(startPosition.offset, this.offset()),\n      err: null\n    };\n  };\n\n  Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n    var tokens = [];\n\n    try {\n      tokens = parseNumberSkeletonFromString(skeleton);\n    } catch (e) {\n      return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\n    }\n\n    return {\n      val: {\n        type: SKELETON_TYPE.number,\n        tokens: tokens,\n        location: location,\n        parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}\n      },\n      err: null\n    };\n  };\n  /**\r\n   * @param nesting_level The current nesting level of messages.\r\n   *     This can be positive when parsing message fragment in select or plural argument options.\r\n   * @param parent_arg_type The parent argument's type.\r\n   * @param parsed_first_identifier If provided, this is the first identifier-like selector of\r\n   *     the argument. It is a by-product of a previous parsing attempt.\r\n   * @param expecting_close_tag If true, this message is directly or indirectly nested inside\r\n   *     between a pair of opening and closing tags. The nested message will not parse beyond\r\n   *     the closing tag boundary.\r\n   */\n\n\n  Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n    var _a;\n\n    var hasOtherClause = false;\n    var options = [];\n    var parsedSelectors = new Set();\n    var selector = parsedFirstIdentifier.value,\n        selectorLocation = parsedFirstIdentifier.location; // Parse:\n    // one {one apple}\n    // ^--^\n\n    while (true) {\n      if (selector.length === 0) {\n        var startPosition = this.clonePosition();\n\n        if (parentArgType !== 'select' && this.bumpIf('=')) {\n          // Try parse `={number}` selector\n          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n\n          if (result.err) {\n            return result;\n          }\n\n          selectorLocation = createLocation(startPosition, this.clonePosition());\n          selector = this.message.slice(startPosition.offset, this.offset());\n        } else {\n          break;\n        }\n      } // Duplicate selector clauses\n\n\n      if (parsedSelectors.has(selector)) {\n        return this.error(parentArgType === 'select' ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n      }\n\n      if (selector === 'other') {\n        hasOtherClause = true;\n      } // Parse:\n      // one {one apple}\n      //     ^----------^\n\n\n      this.bumpSpace();\n      var openingBracePosition = this.clonePosition();\n\n      if (!this.bumpIf('{')) {\n        return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n      }\n\n      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n\n      if (fragmentResult.err) {\n        return fragmentResult;\n      }\n\n      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n      if (argCloseResult.err) {\n        return argCloseResult;\n      }\n\n      options.push([selector, {\n        value: fragmentResult.val,\n        location: createLocation(openingBracePosition, this.clonePosition())\n      }]); // Keep track of the existing selectors\n\n      parsedSelectors.add(selector); // Prep next selector clause.\n\n      this.bumpSpace();\n      _a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location;\n    }\n\n    if (options.length === 0) {\n      return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    if (this.requiresOtherClause && !hasOtherClause) {\n      return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    return {\n      val: options,\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n    var sign = 1;\n    var startingPosition = this.clonePosition();\n\n    if (this.bumpIf('+')) {} else if (this.bumpIf('-')) {\n      sign = -1;\n    }\n\n    var hasDigits = false;\n    var decimal = 0;\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch >= 48\n      /* `0` */\n      && ch <= 57\n      /* `9` */\n      ) {\n          hasDigits = true;\n          decimal = decimal * 10 + (ch - 48);\n          this.bump();\n        } else {\n        break;\n      }\n    }\n\n    var location = createLocation(startingPosition, this.clonePosition());\n\n    if (!hasDigits) {\n      return this.error(expectNumberError, location);\n    }\n\n    decimal *= sign;\n\n    if (!isSafeInteger(decimal)) {\n      return this.error(invalidNumberError, location);\n    }\n\n    return {\n      val: decimal,\n      err: null\n    };\n  };\n\n  Parser.prototype.offset = function () {\n    return this.position.offset;\n  };\n\n  Parser.prototype.isEOF = function () {\n    return this.offset() === this.message.length;\n  };\n\n  Parser.prototype.clonePosition = function () {\n    // This is much faster than `Object.assign` or spread.\n    return {\n      offset: this.position.offset,\n      line: this.position.line,\n      column: this.position.column\n    };\n  };\n  /**\r\n   * Return the code point at the current position of the parser.\r\n   * Throws if the index is out of bound.\r\n   */\n\n\n  Parser.prototype.char = function () {\n    var offset = this.position.offset;\n\n    if (offset >= this.message.length) {\n      throw Error('out of bound');\n    }\n\n    var code = codePointAt(this.message, offset);\n\n    if (code === undefined) {\n      throw Error(\"Offset \" + offset + \" is at invalid UTF-16 code unit boundary\");\n    }\n\n    return code;\n  };\n\n  Parser.prototype.error = function (kind, location) {\n    return {\n      val: null,\n      err: {\n        kind: kind,\n        message: this.message,\n        location: location\n      }\n    };\n  };\n  /** Bump the parser to the next UTF-16 code unit. */\n\n\n  Parser.prototype.bump = function () {\n    if (this.isEOF()) {\n      return;\n    }\n\n    var code = this.char();\n\n    if (code === 10\n    /* '\\n' */\n    ) {\n        this.position.line += 1;\n        this.position.column = 1;\n        this.position.offset += 1;\n      } else {\n      this.position.column += 1; // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n\n      this.position.offset += code < 0x10000 ? 1 : 2;\n    }\n  };\n  /**\r\n   * If the substring starting at the current position of the parser has\r\n   * the given prefix, then bump the parser to the character immediately\r\n   * following the prefix and return true. Otherwise, don't bump the parser\r\n   * and return false.\r\n   */\n\n\n  Parser.prototype.bumpIf = function (prefix) {\n    if (startsWith(this.message, prefix, this.offset())) {\n      for (var i = 0; i < prefix.length; i++) {\n        this.bump();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Bump the parser until the pattern character is found and return `true`.\r\n   * Otherwise bump to the end of the file and return `false`.\r\n   */\n\n\n  Parser.prototype.bumpUntil = function (pattern) {\n    var currentOffset = this.offset();\n    var index = this.message.indexOf(pattern, currentOffset);\n\n    if (index >= 0) {\n      this.bumpTo(index);\n      return true;\n    } else {\n      this.bumpTo(this.message.length);\n      return false;\n    }\n  };\n  /**\r\n   * Bump the parser to the target offset.\r\n   * If target offset is beyond the end of the input, bump the parser to the end of the input.\r\n   */\n\n\n  Parser.prototype.bumpTo = function (targetOffset) {\n    if (this.offset() > targetOffset) {\n      throw Error(\"targetOffset \" + targetOffset + \" must be greater than or equal to the current offset \" + this.offset());\n    }\n\n    targetOffset = Math.min(targetOffset, this.message.length);\n\n    while (true) {\n      var offset = this.offset();\n\n      if (offset === targetOffset) {\n        break;\n      }\n\n      if (offset > targetOffset) {\n        throw Error(\"targetOffset \" + targetOffset + \" is at invalid UTF-16 code unit boundary\");\n      }\n\n      this.bump();\n\n      if (this.isEOF()) {\n        break;\n      }\n    }\n  };\n  /** advance the parser through all whitespace to the next non-whitespace code unit. */\n\n\n  Parser.prototype.bumpSpace = function () {\n    while (!this.isEOF() && _isWhiteSpace(this.char())) {\n      this.bump();\n    }\n  };\n  /**\r\n   * Peek at the *next* Unicode codepoint in the input without advancing the parser.\r\n   * If the input has been exhausted, then this returns null.\r\n   */\n\n\n  Parser.prototype.peek = function () {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var code = this.char();\n    var offset = this.offset();\n    var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n    return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n  };\n\n  return Parser;\n}();\n\nexport { Parser };\n/**\r\n * This check if codepoint is alphabet (lower & uppercase)\r\n * @param codepoint\r\n * @returns\r\n */\n\nfunction _isAlpha(codepoint) {\n  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;\n}\n\nfunction _isAlphaOrSlash(codepoint) {\n  return _isAlpha(codepoint) || codepoint === 47;\n  /* '/' */\n}\n/** See `parseTag` function docs. */\n\n\nfunction _isPotentialElementNameChar(c) {\n  return c === 45\n  /* '-' */\n  || c === 46\n  /* '.' */\n  || c >= 48 && c <= 57\n  /* 0..9 */\n  || c === 95\n  /* '_' */\n  || c >= 97 && c <= 122\n  /** a..z */\n  || c >= 65 && c <= 90\n  /* A..Z */\n  || c == 0xb7 || c >= 0xc0 && c <= 0xd6 || c >= 0xd8 && c <= 0xf6 || c >= 0xf8 && c <= 0x37d || c >= 0x37f && c <= 0x1fff || c >= 0x200c && c <= 0x200d || c >= 0x203f && c <= 0x2040 || c >= 0x2070 && c <= 0x218f || c >= 0x2c00 && c <= 0x2fef || c >= 0x3001 && c <= 0xd7ff || c >= 0xf900 && c <= 0xfdcf || c >= 0xfdf0 && c <= 0xfffd || c >= 0x10000 && c <= 0xeffff;\n}\n/**\r\n * Code point equivalent of regex `\\p{White_Space}`.\r\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\n\n\nfunction _isWhiteSpace(c) {\n  return c >= 0x0009 && c <= 0x000d || c === 0x0020 || c === 0x0085 || c >= 0x200e && c <= 0x200f || c === 0x2028 || c === 0x2029;\n}\n/**\r\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\r\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\n\n\nfunction _isPatternSyntax(c) {\n  return c >= 0x0021 && c <= 0x0023 || c === 0x0024 || c >= 0x0025 && c <= 0x0027 || c === 0x0028 || c === 0x0029 || c === 0x002a || c === 0x002b || c === 0x002c || c === 0x002d || c >= 0x002e && c <= 0x002f || c >= 0x003a && c <= 0x003b || c >= 0x003c && c <= 0x003e || c >= 0x003f && c <= 0x0040 || c === 0x005b || c === 0x005c || c === 0x005d || c === 0x005e || c === 0x0060 || c === 0x007b || c === 0x007c || c === 0x007d || c === 0x007e || c === 0x00a1 || c >= 0x00a2 && c <= 0x00a5 || c === 0x00a6 || c === 0x00a7 || c === 0x00a9 || c === 0x00ab || c === 0x00ac || c === 0x00ae || c === 0x00b0 || c === 0x00b1 || c === 0x00b6 || c === 0x00bb || c === 0x00bf || c === 0x00d7 || c === 0x00f7 || c >= 0x2010 && c <= 0x2015 || c >= 0x2016 && c <= 0x2017 || c === 0x2018 || c === 0x2019 || c === 0x201a || c >= 0x201b && c <= 0x201c || c === 0x201d || c === 0x201e || c === 0x201f || c >= 0x2020 && c <= 0x2027 || c >= 0x2030 && c <= 0x2038 || c === 0x2039 || c === 0x203a || c >= 0x203b && c <= 0x203e || c >= 0x2041 && c <= 0x2043 || c === 0x2044 || c === 0x2045 || c === 0x2046 || c >= 0x2047 && c <= 0x2051 || c === 0x2052 || c === 0x2053 || c >= 0x2055 && c <= 0x205e || c >= 0x2190 && c <= 0x2194 || c >= 0x2195 && c <= 0x2199 || c >= 0x219a && c <= 0x219b || c >= 0x219c && c <= 0x219f || c === 0x21a0 || c >= 0x21a1 && c <= 0x21a2 || c === 0x21a3 || c >= 0x21a4 && c <= 0x21a5 || c === 0x21a6 || c >= 0x21a7 && c <= 0x21ad || c === 0x21ae || c >= 0x21af && c <= 0x21cd || c >= 0x21ce && c <= 0x21cf || c >= 0x21d0 && c <= 0x21d1 || c === 0x21d2 || c === 0x21d3 || c === 0x21d4 || c >= 0x21d5 && c <= 0x21f3 || c >= 0x21f4 && c <= 0x22ff || c >= 0x2300 && c <= 0x2307 || c === 0x2308 || c === 0x2309 || c === 0x230a || c === 0x230b || c >= 0x230c && c <= 0x231f || c >= 0x2320 && c <= 0x2321 || c >= 0x2322 && c <= 0x2328 || c === 0x2329 || c === 0x232a || c >= 0x232b && c <= 0x237b || c === 0x237c || c >= 0x237d && c <= 0x239a || c >= 0x239b && c <= 0x23b3 || c >= 0x23b4 && c <= 0x23db || c >= 0x23dc && c <= 0x23e1 || c >= 0x23e2 && c <= 0x2426 || c >= 0x2427 && c <= 0x243f || c >= 0x2440 && c <= 0x244a || c >= 0x244b && c <= 0x245f || c >= 0x2500 && c <= 0x25b6 || c === 0x25b7 || c >= 0x25b8 && c <= 0x25c0 || c === 0x25c1 || c >= 0x25c2 && c <= 0x25f7 || c >= 0x25f8 && c <= 0x25ff || c >= 0x2600 && c <= 0x266e || c === 0x266f || c >= 0x2670 && c <= 0x2767 || c === 0x2768 || c === 0x2769 || c === 0x276a || c === 0x276b || c === 0x276c || c === 0x276d || c === 0x276e || c === 0x276f || c === 0x2770 || c === 0x2771 || c === 0x2772 || c === 0x2773 || c === 0x2774 || c === 0x2775 || c >= 0x2794 && c <= 0x27bf || c >= 0x27c0 && c <= 0x27c4 || c === 0x27c5 || c === 0x27c6 || c >= 0x27c7 && c <= 0x27e5 || c === 0x27e6 || c === 0x27e7 || c === 0x27e8 || c === 0x27e9 || c === 0x27ea || c === 0x27eb || c === 0x27ec || c === 0x27ed || c === 0x27ee || c === 0x27ef || c >= 0x27f0 && c <= 0x27ff || c >= 0x2800 && c <= 0x28ff || c >= 0x2900 && c <= 0x2982 || c === 0x2983 || c === 0x2984 || c === 0x2985 || c === 0x2986 || c === 0x2987 || c === 0x2988 || c === 0x2989 || c === 0x298a || c === 0x298b || c === 0x298c || c === 0x298d || c === 0x298e || c === 0x298f || c === 0x2990 || c === 0x2991 || c === 0x2992 || c === 0x2993 || c === 0x2994 || c === 0x2995 || c === 0x2996 || c === 0x2997 || c === 0x2998 || c >= 0x2999 && c <= 0x29d7 || c === 0x29d8 || c === 0x29d9 || c === 0x29da || c === 0x29db || c >= 0x29dc && c <= 0x29fb || c === 0x29fc || c === 0x29fd || c >= 0x29fe && c <= 0x2aff || c >= 0x2b00 && c <= 0x2b2f || c >= 0x2b30 && c <= 0x2b44 || c >= 0x2b45 && c <= 0x2b46 || c >= 0x2b47 && c <= 0x2b4c || c >= 0x2b4d && c <= 0x2b73 || c >= 0x2b74 && c <= 0x2b75 || c >= 0x2b76 && c <= 0x2b95 || c === 0x2b96 || c >= 0x2b97 && c <= 0x2bff || c >= 0x2e00 && c <= 0x2e01 || c === 0x2e02 || c === 0x2e03 || c === 0x2e04 || c === 0x2e05 || c >= 0x2e06 && c <= 0x2e08 || c === 0x2e09 || c === 0x2e0a || c === 0x2e0b || c === 0x2e0c || c === 0x2e0d || c >= 0x2e0e && c <= 0x2e16 || c === 0x2e17 || c >= 0x2e18 && c <= 0x2e19 || c === 0x2e1a || c === 0x2e1b || c === 0x2e1c || c === 0x2e1d || c >= 0x2e1e && c <= 0x2e1f || c === 0x2e20 || c === 0x2e21 || c === 0x2e22 || c === 0x2e23 || c === 0x2e24 || c === 0x2e25 || c === 0x2e26 || c === 0x2e27 || c === 0x2e28 || c === 0x2e29 || c >= 0x2e2a && c <= 0x2e2e || c === 0x2e2f || c >= 0x2e30 && c <= 0x2e39 || c >= 0x2e3a && c <= 0x2e3b || c >= 0x2e3c && c <= 0x2e3f || c === 0x2e40 || c === 0x2e41 || c === 0x2e42 || c >= 0x2e43 && c <= 0x2e4f || c >= 0x2e50 && c <= 0x2e51 || c === 0x2e52 || c >= 0x2e53 && c <= 0x2e7f || c >= 0x3001 && c <= 0x3003 || c === 0x3008 || c === 0x3009 || c === 0x300a || c === 0x300b || c === 0x300c || c === 0x300d || c === 0x300e || c === 0x300f || c === 0x3010 || c === 0x3011 || c >= 0x3012 && c <= 0x3013 || c === 0x3014 || c === 0x3015 || c === 0x3016 || c === 0x3017 || c === 0x3018 || c === 0x3019 || c === 0x301a || c === 0x301b || c === 0x301c || c === 0x301d || c >= 0x301e && c <= 0x301f || c === 0x3020 || c === 0x3030 || c === 0xfd3e || c === 0xfd3f || c >= 0xfe45 && c <= 0xfe46;\n}","map":{"version":3,"sources":["C:/Users/dangk/Documents/webFullstack/frontendReactJS/Frontend-React.JS-QuickStart/node_modules/@formatjs/icu-messageformat-parser/lib/parser.js"],"names":["_a","__assign","ErrorKind","SKELETON_TYPE","TYPE","SPACE_SEPARATOR_REGEX","parseNumberSkeleton","parseNumberSkeletonFromString","parseDateTimeSkeleton","SPACE_SEPARATOR_START_REGEX","RegExp","source","SPACE_SEPARATOR_END_REGEX","createLocation","start","end","hasNativeStartsWith","String","prototype","startsWith","hasNativeFromCodePoint","fromCodePoint","hasNativeFromEntries","Object","fromEntries","hasNativeCodePointAt","codePointAt","hasTrimStart","trimStart","hasTrimEnd","trimEnd","hasNativeIsSafeInteger","Number","isSafeInteger","n","isFinite","Math","floor","abs","REGEX_SUPPORTS_U_AND_Y","re","RE","exec","_","s","search","position","slice","length","codePoints","_i","arguments","elements","i","code","RangeError","fromCharCode","entries","obj","entries_1","k","v","index","size","undefined","first","charCodeAt","second","replace","flag","matchIdentifierAtIndex","IDENTIFIER_PREFIX_RE_1","lastIndex","match","c","_isWhiteSpace","_isPatternSyntax","push","apply","Parser","message","options","offset","line","column","ignoreTag","requiresOtherClause","shouldParseSkeletons","parse","Error","parseMessage","nestingLevel","parentArgType","expectingCloseTag","isEOF","char","result","parseArgument","err","val","clonePosition","bump","type","pound","location","peek","error","UNMATCHED_CLOSING_TAG","_isAlpha","parseTag","parseLiteral","startPosition","tagName","parseTagName","bumpSpace","bumpIf","literal","value","childrenResult","children","endTagStartPosition","INVALID_TAG","closingTagNameStartPosition","closingTagName","tag","UNCLOSED_TAG","startOffset","_isPotentialElementNameChar","parseQuoteResult","tryParseQuote","parseUnquotedResult","tryParseUnquoted","parseLeftAngleResult","tryParseLeftAngleBracket","_isAlphaOrSlash","ch","openingBracePosition","EXPECT_ARGUMENT_CLOSING_BRACE","EMPTY_ARGUMENT","parseIdentifierIfPossible","MALFORMED_ARGUMENT","argument","parseArgumentOptions","startingPosition","endOffset","bumpTo","endPosition","typeStartPosition","argType","typeEndPosition","EXPECT_ARGUMENT_TYPE","styleAndLocation","styleStartPosition","parseSimpleArgStyleIfPossible","style","EXPECT_ARGUMENT_STYLE","styleLocation","argCloseResult","tryParseArgumentClose","location_1","skeleton","number","EXPECT_DATE_TIME_SKELETON","dateTime","pattern","parsedOptions","date","time","typeEndPosition_1","EXPECT_SELECT_ARGUMENT_OPTIONS","identifierAndLocation","pluralOffset","EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE","tryParseDecimalInteger","INVALID_PLURAL_ARGUMENT_OFFSET_VALUE","optionsResult","tryParsePluralOrSelectOptions","location_2","select","plural","pluralType","INVALID_ARGUMENT_TYPE","nestedBraces","apostrophePosition","bumpUntil","UNCLOSED_QUOTE_IN_ARGUMENT_STYLE","tokens","e","INVALID_NUMBER_SKELETON","expectCloseTag","parsedFirstIdentifier","hasOtherClause","parsedSelectors","Set","selector","selectorLocation","EXPECT_PLURAL_ARGUMENT_SELECTOR","INVALID_PLURAL_ARGUMENT_SELECTOR","has","DUPLICATE_SELECT_ARGUMENT_SELECTOR","DUPLICATE_PLURAL_ARGUMENT_SELECTOR","EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT","EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT","fragmentResult","add","EXPECT_SELECT_ARGUMENT_SELECTOR","MISSING_OTHER_CLAUSE","expectNumberError","invalidNumberError","sign","hasDigits","decimal","kind","prefix","currentOffset","indexOf","targetOffset","min","nextCode","codepoint"],"mappings":"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","sourcesContent":["var _a;\r\nimport { __assign } from \"tslib\";\r\nimport { ErrorKind } from './error';\r\nimport { SKELETON_TYPE, TYPE, } from './types';\r\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\r\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton, } from '@formatjs/icu-skeleton-parser';\r\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\" + SPACE_SEPARATOR_REGEX.source + \"*\");\r\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(SPACE_SEPARATOR_REGEX.source + \"*$\");\r\nfunction createLocation(start, end) {\r\n    return { start: start, end: end };\r\n}\r\n// #region Ponyfills\r\n// Consolidate these variables up top for easier toggling during debugging\r\nvar hasNativeStartsWith = !!String.prototype.startsWith;\r\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\r\nvar hasNativeFromEntries = !!Object.fromEntries;\r\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\r\nvar hasTrimStart = !!String.prototype.trimStart;\r\nvar hasTrimEnd = !!String.prototype.trimEnd;\r\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\r\nvar isSafeInteger = hasNativeIsSafeInteger\r\n    ? Number.isSafeInteger\r\n    : function (n) {\r\n        return (typeof n === 'number' &&\r\n            isFinite(n) &&\r\n            Math.floor(n) === n &&\r\n            Math.abs(n) <= 0x1fffffffffffff);\r\n    };\r\n// IE11 does not support y and u.\r\nvar REGEX_SUPPORTS_U_AND_Y = true;\r\ntry {\r\n    var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\r\n    /**\r\n     * legacy Edge or Xbox One browser\r\n     * Unicode flag support: supported\r\n     * Pattern_Syntax support: not supported\r\n     * See https://github.com/formatjs/formatjs/issues/2822\r\n     */\r\n    REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\r\n}\r\ncatch (_) {\r\n    REGEX_SUPPORTS_U_AND_Y = false;\r\n}\r\nvar startsWith = hasNativeStartsWith\r\n    ? // Native\r\n        function startsWith(s, search, position) {\r\n            return s.startsWith(search, position);\r\n        }\r\n    : // For IE11\r\n        function startsWith(s, search, position) {\r\n            return s.slice(position, position + search.length) === search;\r\n        };\r\nvar fromCodePoint = hasNativeFromCodePoint\r\n    ? String.fromCodePoint\r\n    : // IE11\r\n        function fromCodePoint() {\r\n            var codePoints = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                codePoints[_i] = arguments[_i];\r\n            }\r\n            var elements = '';\r\n            var length = codePoints.length;\r\n            var i = 0;\r\n            var code;\r\n            while (length > i) {\r\n                code = codePoints[i++];\r\n                if (code > 0x10ffff)\r\n                    throw RangeError(code + ' is not a valid code point');\r\n                elements +=\r\n                    code < 0x10000\r\n                        ? String.fromCharCode(code)\r\n                        : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);\r\n            }\r\n            return elements;\r\n        };\r\nvar fromEntries = \r\n// native\r\nhasNativeFromEntries\r\n    ? Object.fromEntries\r\n    : // Ponyfill\r\n        function fromEntries(entries) {\r\n            var obj = {};\r\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\r\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\r\n                obj[k] = v;\r\n            }\r\n            return obj;\r\n        };\r\nvar codePointAt = hasNativeCodePointAt\r\n    ? // Native\r\n        function codePointAt(s, index) {\r\n            return s.codePointAt(index);\r\n        }\r\n    : // IE 11\r\n        function codePointAt(s, index) {\r\n            var size = s.length;\r\n            if (index < 0 || index >= size) {\r\n                return undefined;\r\n            }\r\n            var first = s.charCodeAt(index);\r\n            var second;\r\n            return first < 0xd800 ||\r\n                first > 0xdbff ||\r\n                index + 1 === size ||\r\n                (second = s.charCodeAt(index + 1)) < 0xdc00 ||\r\n                second > 0xdfff\r\n                ? first\r\n                : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;\r\n        };\r\nvar trimStart = hasTrimStart\r\n    ? // Native\r\n        function trimStart(s) {\r\n            return s.trimStart();\r\n        }\r\n    : // Ponyfill\r\n        function trimStart(s) {\r\n            return s.replace(SPACE_SEPARATOR_START_REGEX, '');\r\n        };\r\nvar trimEnd = hasTrimEnd\r\n    ? // Native\r\n        function trimEnd(s) {\r\n            return s.trimEnd();\r\n        }\r\n    : // Ponyfill\r\n        function trimEnd(s) {\r\n            return s.replace(SPACE_SEPARATOR_END_REGEX, '');\r\n        };\r\n// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\r\nfunction RE(s, flag) {\r\n    return new RegExp(s, flag);\r\n}\r\n// #endregion\r\nvar matchIdentifierAtIndex;\r\nif (REGEX_SUPPORTS_U_AND_Y) {\r\n    // Native\r\n    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\r\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\r\n        var _a;\r\n        IDENTIFIER_PREFIX_RE_1.lastIndex = index;\r\n        var match = IDENTIFIER_PREFIX_RE_1.exec(s);\r\n        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\r\n    };\r\n}\r\nelse {\r\n    // IE11\r\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\r\n        var match = [];\r\n        while (true) {\r\n            var c = codePointAt(s, index);\r\n            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\r\n                break;\r\n            }\r\n            match.push(c);\r\n            index += c >= 0x10000 ? 2 : 1;\r\n        }\r\n        return fromCodePoint.apply(void 0, match);\r\n    };\r\n}\r\nvar Parser = /** @class */ (function () {\r\n    function Parser(message, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.message = message;\r\n        this.position = { offset: 0, line: 1, column: 1 };\r\n        this.ignoreTag = !!options.ignoreTag;\r\n        this.requiresOtherClause = !!options.requiresOtherClause;\r\n        this.shouldParseSkeletons = !!options.shouldParseSkeletons;\r\n    }\r\n    Parser.prototype.parse = function () {\r\n        if (this.offset() !== 0) {\r\n            throw Error('parser can only be used once');\r\n        }\r\n        return this.parseMessage(0, '', false);\r\n    };\r\n    Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\r\n        var elements = [];\r\n        while (!this.isEOF()) {\r\n            var char = this.char();\r\n            if (char === 123 /* `{` */) {\r\n                var result = this.parseArgument(nestingLevel, expectingCloseTag);\r\n                if (result.err) {\r\n                    return result;\r\n                }\r\n                elements.push(result.val);\r\n            }\r\n            else if (char === 125 /* `}` */ && nestingLevel > 0) {\r\n                break;\r\n            }\r\n            else if (char === 35 /* `#` */ &&\r\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\r\n                var position = this.clonePosition();\r\n                this.bump();\r\n                elements.push({\r\n                    type: TYPE.pound,\r\n                    location: createLocation(position, this.clonePosition()),\r\n                });\r\n            }\r\n            else if (char === 60 /* `<` */ &&\r\n                !this.ignoreTag &&\r\n                this.peek() === 47 // char code for '/'\r\n            ) {\r\n                if (expectingCloseTag) {\r\n                    break;\r\n                }\r\n                else {\r\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\r\n                }\r\n            }\r\n            else if (char === 60 /* `<` */ &&\r\n                !this.ignoreTag &&\r\n                _isAlpha(this.peek() || 0)) {\r\n                var result = this.parseTag(nestingLevel, parentArgType);\r\n                if (result.err) {\r\n                    return result;\r\n                }\r\n                elements.push(result.val);\r\n            }\r\n            else {\r\n                var result = this.parseLiteral(nestingLevel, parentArgType);\r\n                if (result.err) {\r\n                    return result;\r\n                }\r\n                elements.push(result.val);\r\n            }\r\n        }\r\n        return { val: elements, err: null };\r\n    };\r\n    /**\r\n     * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\r\n     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\r\n     * are accepted:\r\n     *\r\n     * ```\r\n     * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\r\n     * tagName ::= [a-z] (PENChar)*\r\n     * PENChar ::=\r\n     *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\r\n     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\r\n     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n     * ```\r\n     *\r\n     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\r\n     * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\r\n     * since other tag-based engines like React allow it\r\n     */\r\n    Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\r\n        var startPosition = this.clonePosition();\r\n        this.bump(); // `<`\r\n        var tagName = this.parseTagName();\r\n        this.bumpSpace();\r\n        if (this.bumpIf('/>')) {\r\n            // Self closing tag\r\n            return {\r\n                val: {\r\n                    type: TYPE.literal,\r\n                    value: \"<\" + tagName + \"/>\",\r\n                    location: createLocation(startPosition, this.clonePosition()),\r\n                },\r\n                err: null,\r\n            };\r\n        }\r\n        else if (this.bumpIf('>')) {\r\n            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\r\n            if (childrenResult.err) {\r\n                return childrenResult;\r\n            }\r\n            var children = childrenResult.val;\r\n            // Expecting a close tag\r\n            var endTagStartPosition = this.clonePosition();\r\n            if (this.bumpIf('</')) {\r\n                if (this.isEOF() || !_isAlpha(this.char())) {\r\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\r\n                }\r\n                var closingTagNameStartPosition = this.clonePosition();\r\n                var closingTagName = this.parseTagName();\r\n                if (tagName !== closingTagName) {\r\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\r\n                }\r\n                this.bumpSpace();\r\n                if (!this.bumpIf('>')) {\r\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\r\n                }\r\n                return {\r\n                    val: {\r\n                        type: TYPE.tag,\r\n                        value: tagName,\r\n                        children: children,\r\n                        location: createLocation(startPosition, this.clonePosition()),\r\n                    },\r\n                    err: null,\r\n                };\r\n            }\r\n            else {\r\n                return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\r\n            }\r\n        }\r\n        else {\r\n            return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\r\n        }\r\n    };\r\n    /**\r\n     * This method assumes that the caller has peeked ahead for the first tag character.\r\n     */\r\n    Parser.prototype.parseTagName = function () {\r\n        var startOffset = this.offset();\r\n        this.bump(); // the first tag name character\r\n        while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\r\n            this.bump();\r\n        }\r\n        return this.message.slice(startOffset, this.offset());\r\n    };\r\n    Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\r\n        var start = this.clonePosition();\r\n        var value = '';\r\n        while (true) {\r\n            var parseQuoteResult = this.tryParseQuote(parentArgType);\r\n            if (parseQuoteResult) {\r\n                value += parseQuoteResult;\r\n                continue;\r\n            }\r\n            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\r\n            if (parseUnquotedResult) {\r\n                value += parseUnquotedResult;\r\n                continue;\r\n            }\r\n            var parseLeftAngleResult = this.tryParseLeftAngleBracket();\r\n            if (parseLeftAngleResult) {\r\n                value += parseLeftAngleResult;\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        var location = createLocation(start, this.clonePosition());\r\n        return {\r\n            val: { type: TYPE.literal, value: value, location: location },\r\n            err: null,\r\n        };\r\n    };\r\n    Parser.prototype.tryParseLeftAngleBracket = function () {\r\n        if (!this.isEOF() &&\r\n            this.char() === 60 /* `<` */ &&\r\n            (this.ignoreTag ||\r\n                // If at the opening tag or closing tag position, bail.\r\n                !_isAlphaOrSlash(this.peek() || 0))) {\r\n            this.bump(); // `<`\r\n            return '<';\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\r\n     * a character that requires quoting (that is, \"only where needed\"), and works the same in\r\n     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\r\n     */\r\n    Parser.prototype.tryParseQuote = function (parentArgType) {\r\n        if (this.isEOF() || this.char() !== 39 /* `'` */) {\r\n            return null;\r\n        }\r\n        // Parse escaped char following the apostrophe, or early return if there is no escaped char.\r\n        // Check if is valid escaped character\r\n        switch (this.peek()) {\r\n            case 39 /* `'` */:\r\n                // double quote, should return as a single quote.\r\n                this.bump();\r\n                this.bump();\r\n                return \"'\";\r\n            // '{', '<', '>', '}'\r\n            case 123:\r\n            case 60:\r\n            case 62:\r\n            case 125:\r\n                break;\r\n            case 35: // '#'\r\n                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\r\n                    break;\r\n                }\r\n                return null;\r\n            default:\r\n                return null;\r\n        }\r\n        this.bump(); // apostrophe\r\n        var codePoints = [this.char()]; // escaped char\r\n        this.bump();\r\n        // read chars until the optional closing apostrophe is found\r\n        while (!this.isEOF()) {\r\n            var ch = this.char();\r\n            if (ch === 39 /* `'` */) {\r\n                if (this.peek() === 39 /* `'` */) {\r\n                    codePoints.push(39);\r\n                    // Bump one more time because we need to skip 2 characters.\r\n                    this.bump();\r\n                }\r\n                else {\r\n                    // Optional closing apostrophe.\r\n                    this.bump();\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                codePoints.push(ch);\r\n            }\r\n            this.bump();\r\n        }\r\n        return fromCodePoint.apply(void 0, codePoints);\r\n    };\r\n    Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\r\n        if (this.isEOF()) {\r\n            return null;\r\n        }\r\n        var ch = this.char();\r\n        if (ch === 60 /* `<` */ ||\r\n            ch === 123 /* `{` */ ||\r\n            (ch === 35 /* `#` */ &&\r\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||\r\n            (ch === 125 /* `}` */ && nestingLevel > 0)) {\r\n            return null;\r\n        }\r\n        else {\r\n            this.bump();\r\n            return fromCodePoint(ch);\r\n        }\r\n    };\r\n    Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\r\n        var openingBracePosition = this.clonePosition();\r\n        this.bump(); // `{`\r\n        this.bumpSpace();\r\n        if (this.isEOF()) {\r\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        if (this.char() === 125 /* `}` */) {\r\n            this.bump();\r\n            return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        // argument name\r\n        var value = this.parseIdentifierIfPossible().value;\r\n        if (!value) {\r\n            return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        this.bumpSpace();\r\n        if (this.isEOF()) {\r\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        switch (this.char()) {\r\n            // Simple argument: `{name}`\r\n            case 125 /* `}` */: {\r\n                this.bump(); // `}`\r\n                return {\r\n                    val: {\r\n                        type: TYPE.argument,\r\n                        // value does not include the opening and closing braces.\r\n                        value: value,\r\n                        location: createLocation(openingBracePosition, this.clonePosition()),\r\n                    },\r\n                    err: null,\r\n                };\r\n            }\r\n            // Argument with options: `{name, format, ...}`\r\n            case 44 /* `,` */: {\r\n                this.bump(); // `,`\r\n                this.bumpSpace();\r\n                if (this.isEOF()) {\r\n                    return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n                }\r\n                return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\r\n            }\r\n            default:\r\n                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n    };\r\n    /**\r\n     * Advance the parser until the end of the identifier, if it is currently on\r\n     * an identifier character. Return an empty string otherwise.\r\n     */\r\n    Parser.prototype.parseIdentifierIfPossible = function () {\r\n        var startingPosition = this.clonePosition();\r\n        var startOffset = this.offset();\r\n        var value = matchIdentifierAtIndex(this.message, startOffset);\r\n        var endOffset = startOffset + value.length;\r\n        this.bumpTo(endOffset);\r\n        var endPosition = this.clonePosition();\r\n        var location = createLocation(startingPosition, endPosition);\r\n        return { value: value, location: location };\r\n    };\r\n    Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\r\n        var _a;\r\n        // Parse this range:\r\n        // {name, type, style}\r\n        //        ^---^\r\n        var typeStartPosition = this.clonePosition();\r\n        var argType = this.parseIdentifierIfPossible().value;\r\n        var typeEndPosition = this.clonePosition();\r\n        switch (argType) {\r\n            case '':\r\n                // Expecting a style string number, date, time, plural, selectordinal, or select.\r\n                return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\r\n            case 'number':\r\n            case 'date':\r\n            case 'time': {\r\n                // Parse this range:\r\n                // {name, number, style}\r\n                //              ^-------^\r\n                this.bumpSpace();\r\n                var styleAndLocation = null;\r\n                if (this.bumpIf(',')) {\r\n                    this.bumpSpace();\r\n                    var styleStartPosition = this.clonePosition();\r\n                    var result = this.parseSimpleArgStyleIfPossible();\r\n                    if (result.err) {\r\n                        return result;\r\n                    }\r\n                    var style = trimEnd(result.val);\r\n                    if (style.length === 0) {\r\n                        return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\r\n                    }\r\n                    var styleLocation = createLocation(styleStartPosition, this.clonePosition());\r\n                    styleAndLocation = { style: style, styleLocation: styleLocation };\r\n                }\r\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\r\n                if (argCloseResult.err) {\r\n                    return argCloseResult;\r\n                }\r\n                var location_1 = createLocation(openingBracePosition, this.clonePosition());\r\n                // Extract style or skeleton\r\n                if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\r\n                    // Skeleton starts with `::`.\r\n                    var skeleton = trimStart(styleAndLocation.style.slice(2));\r\n                    if (argType === 'number') {\r\n                        var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\r\n                        if (result.err) {\r\n                            return result;\r\n                        }\r\n                        return {\r\n                            val: { type: TYPE.number, value: value, location: location_1, style: result.val },\r\n                            err: null,\r\n                        };\r\n                    }\r\n                    else {\r\n                        if (skeleton.length === 0) {\r\n                            return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\r\n                        }\r\n                        var style = {\r\n                            type: SKELETON_TYPE.dateTime,\r\n                            pattern: skeleton,\r\n                            location: styleAndLocation.styleLocation,\r\n                            parsedOptions: this.shouldParseSkeletons\r\n                                ? parseDateTimeSkeleton(skeleton)\r\n                                : {},\r\n                        };\r\n                        var type = argType === 'date' ? TYPE.date : TYPE.time;\r\n                        return {\r\n                            val: { type: type, value: value, location: location_1, style: style },\r\n                            err: null,\r\n                        };\r\n                    }\r\n                }\r\n                // Regular style or no style.\r\n                return {\r\n                    val: {\r\n                        type: argType === 'number'\r\n                            ? TYPE.number\r\n                            : argType === 'date'\r\n                                ? TYPE.date\r\n                                : TYPE.time,\r\n                        value: value,\r\n                        location: location_1,\r\n                        style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,\r\n                    },\r\n                    err: null,\r\n                };\r\n            }\r\n            case 'plural':\r\n            case 'selectordinal':\r\n            case 'select': {\r\n                // Parse this range:\r\n                // {name, plural, options}\r\n                //              ^---------^\r\n                var typeEndPosition_1 = this.clonePosition();\r\n                this.bumpSpace();\r\n                if (!this.bumpIf(',')) {\r\n                    return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\r\n                }\r\n                this.bumpSpace();\r\n                // Parse offset:\r\n                // {name, plural, offset:1, options}\r\n                //                ^-----^\r\n                //\r\n                // or the first option:\r\n                //\r\n                // {name, plural, one {...} other {...}}\r\n                //                ^--^\r\n                var identifierAndLocation = this.parseIdentifierIfPossible();\r\n                var pluralOffset = 0;\r\n                if (argType !== 'select' && identifierAndLocation.value === 'offset') {\r\n                    if (!this.bumpIf(':')) {\r\n                        return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\r\n                    }\r\n                    this.bumpSpace();\r\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\r\n                    if (result.err) {\r\n                        return result;\r\n                    }\r\n                    // Parse another identifier for option parsing\r\n                    this.bumpSpace();\r\n                    identifierAndLocation = this.parseIdentifierIfPossible();\r\n                    pluralOffset = result.val;\r\n                }\r\n                var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\r\n                if (optionsResult.err) {\r\n                    return optionsResult;\r\n                }\r\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\r\n                if (argCloseResult.err) {\r\n                    return argCloseResult;\r\n                }\r\n                var location_2 = createLocation(openingBracePosition, this.clonePosition());\r\n                if (argType === 'select') {\r\n                    return {\r\n                        val: {\r\n                            type: TYPE.select,\r\n                            value: value,\r\n                            options: fromEntries(optionsResult.val),\r\n                            location: location_2,\r\n                        },\r\n                        err: null,\r\n                    };\r\n                }\r\n                else {\r\n                    return {\r\n                        val: {\r\n                            type: TYPE.plural,\r\n                            value: value,\r\n                            options: fromEntries(optionsResult.val),\r\n                            offset: pluralOffset,\r\n                            pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\r\n                            location: location_2,\r\n                        },\r\n                        err: null,\r\n                    };\r\n                }\r\n            }\r\n            default:\r\n                return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\r\n        }\r\n    };\r\n    Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\r\n        // Parse: {value, number, ::currency/GBP }\r\n        //\r\n        if (this.isEOF() || this.char() !== 125 /* `}` */) {\r\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\r\n        }\r\n        this.bump(); // `}`\r\n        return { val: true, err: null };\r\n    };\r\n    /**\r\n     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\r\n     */\r\n    Parser.prototype.parseSimpleArgStyleIfPossible = function () {\r\n        var nestedBraces = 0;\r\n        var startPosition = this.clonePosition();\r\n        while (!this.isEOF()) {\r\n            var ch = this.char();\r\n            switch (ch) {\r\n                case 39 /* `'` */: {\r\n                    // Treat apostrophe as quoting but include it in the style part.\r\n                    // Find the end of the quoted literal text.\r\n                    this.bump();\r\n                    var apostrophePosition = this.clonePosition();\r\n                    if (!this.bumpUntil(\"'\")) {\r\n                        return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\r\n                    }\r\n                    this.bump();\r\n                    break;\r\n                }\r\n                case 123 /* `{` */: {\r\n                    nestedBraces += 1;\r\n                    this.bump();\r\n                    break;\r\n                }\r\n                case 125 /* `}` */: {\r\n                    if (nestedBraces > 0) {\r\n                        nestedBraces -= 1;\r\n                    }\r\n                    else {\r\n                        return {\r\n                            val: this.message.slice(startPosition.offset, this.offset()),\r\n                            err: null,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    this.bump();\r\n                    break;\r\n            }\r\n        }\r\n        return {\r\n            val: this.message.slice(startPosition.offset, this.offset()),\r\n            err: null,\r\n        };\r\n    };\r\n    Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\r\n        var tokens = [];\r\n        try {\r\n            tokens = parseNumberSkeletonFromString(skeleton);\r\n        }\r\n        catch (e) {\r\n            return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\r\n        }\r\n        return {\r\n            val: {\r\n                type: SKELETON_TYPE.number,\r\n                tokens: tokens,\r\n                location: location,\r\n                parsedOptions: this.shouldParseSkeletons\r\n                    ? parseNumberSkeleton(tokens)\r\n                    : {},\r\n            },\r\n            err: null,\r\n        };\r\n    };\r\n    /**\r\n     * @param nesting_level The current nesting level of messages.\r\n     *     This can be positive when parsing message fragment in select or plural argument options.\r\n     * @param parent_arg_type The parent argument's type.\r\n     * @param parsed_first_identifier If provided, this is the first identifier-like selector of\r\n     *     the argument. It is a by-product of a previous parsing attempt.\r\n     * @param expecting_close_tag If true, this message is directly or indirectly nested inside\r\n     *     between a pair of opening and closing tags. The nested message will not parse beyond\r\n     *     the closing tag boundary.\r\n     */\r\n    Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\r\n        var _a;\r\n        var hasOtherClause = false;\r\n        var options = [];\r\n        var parsedSelectors = new Set();\r\n        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;\r\n        // Parse:\r\n        // one {one apple}\r\n        // ^--^\r\n        while (true) {\r\n            if (selector.length === 0) {\r\n                var startPosition = this.clonePosition();\r\n                if (parentArgType !== 'select' && this.bumpIf('=')) {\r\n                    // Try parse `={number}` selector\r\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\r\n                    if (result.err) {\r\n                        return result;\r\n                    }\r\n                    selectorLocation = createLocation(startPosition, this.clonePosition());\r\n                    selector = this.message.slice(startPosition.offset, this.offset());\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            // Duplicate selector clauses\r\n            if (parsedSelectors.has(selector)) {\r\n                return this.error(parentArgType === 'select'\r\n                    ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR\r\n                    : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\r\n            }\r\n            if (selector === 'other') {\r\n                hasOtherClause = true;\r\n            }\r\n            // Parse:\r\n            // one {one apple}\r\n            //     ^----------^\r\n            this.bumpSpace();\r\n            var openingBracePosition = this.clonePosition();\r\n            if (!this.bumpIf('{')) {\r\n                return this.error(parentArgType === 'select'\r\n                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT\r\n                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\r\n            }\r\n            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\r\n            if (fragmentResult.err) {\r\n                return fragmentResult;\r\n            }\r\n            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\r\n            if (argCloseResult.err) {\r\n                return argCloseResult;\r\n            }\r\n            options.push([\r\n                selector,\r\n                {\r\n                    value: fragmentResult.val,\r\n                    location: createLocation(openingBracePosition, this.clonePosition()),\r\n                },\r\n            ]);\r\n            // Keep track of the existing selectors\r\n            parsedSelectors.add(selector);\r\n            // Prep next selector clause.\r\n            this.bumpSpace();\r\n            (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);\r\n        }\r\n        if (options.length === 0) {\r\n            return this.error(parentArgType === 'select'\r\n                ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR\r\n                : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\r\n        }\r\n        if (this.requiresOtherClause && !hasOtherClause) {\r\n            return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\r\n        }\r\n        return { val: options, err: null };\r\n    };\r\n    Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\r\n        var sign = 1;\r\n        var startingPosition = this.clonePosition();\r\n        if (this.bumpIf('+')) {\r\n        }\r\n        else if (this.bumpIf('-')) {\r\n            sign = -1;\r\n        }\r\n        var hasDigits = false;\r\n        var decimal = 0;\r\n        while (!this.isEOF()) {\r\n            var ch = this.char();\r\n            if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {\r\n                hasDigits = true;\r\n                decimal = decimal * 10 + (ch - 48);\r\n                this.bump();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        var location = createLocation(startingPosition, this.clonePosition());\r\n        if (!hasDigits) {\r\n            return this.error(expectNumberError, location);\r\n        }\r\n        decimal *= sign;\r\n        if (!isSafeInteger(decimal)) {\r\n            return this.error(invalidNumberError, location);\r\n        }\r\n        return { val: decimal, err: null };\r\n    };\r\n    Parser.prototype.offset = function () {\r\n        return this.position.offset;\r\n    };\r\n    Parser.prototype.isEOF = function () {\r\n        return this.offset() === this.message.length;\r\n    };\r\n    Parser.prototype.clonePosition = function () {\r\n        // This is much faster than `Object.assign` or spread.\r\n        return {\r\n            offset: this.position.offset,\r\n            line: this.position.line,\r\n            column: this.position.column,\r\n        };\r\n    };\r\n    /**\r\n     * Return the code point at the current position of the parser.\r\n     * Throws if the index is out of bound.\r\n     */\r\n    Parser.prototype.char = function () {\r\n        var offset = this.position.offset;\r\n        if (offset >= this.message.length) {\r\n            throw Error('out of bound');\r\n        }\r\n        var code = codePointAt(this.message, offset);\r\n        if (code === undefined) {\r\n            throw Error(\"Offset \" + offset + \" is at invalid UTF-16 code unit boundary\");\r\n        }\r\n        return code;\r\n    };\r\n    Parser.prototype.error = function (kind, location) {\r\n        return {\r\n            val: null,\r\n            err: {\r\n                kind: kind,\r\n                message: this.message,\r\n                location: location,\r\n            },\r\n        };\r\n    };\r\n    /** Bump the parser to the next UTF-16 code unit. */\r\n    Parser.prototype.bump = function () {\r\n        if (this.isEOF()) {\r\n            return;\r\n        }\r\n        var code = this.char();\r\n        if (code === 10 /* '\\n' */) {\r\n            this.position.line += 1;\r\n            this.position.column = 1;\r\n            this.position.offset += 1;\r\n        }\r\n        else {\r\n            this.position.column += 1;\r\n            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\r\n            this.position.offset += code < 0x10000 ? 1 : 2;\r\n        }\r\n    };\r\n    /**\r\n     * If the substring starting at the current position of the parser has\r\n     * the given prefix, then bump the parser to the character immediately\r\n     * following the prefix and return true. Otherwise, don't bump the parser\r\n     * and return false.\r\n     */\r\n    Parser.prototype.bumpIf = function (prefix) {\r\n        if (startsWith(this.message, prefix, this.offset())) {\r\n            for (var i = 0; i < prefix.length; i++) {\r\n                this.bump();\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Bump the parser until the pattern character is found and return `true`.\r\n     * Otherwise bump to the end of the file and return `false`.\r\n     */\r\n    Parser.prototype.bumpUntil = function (pattern) {\r\n        var currentOffset = this.offset();\r\n        var index = this.message.indexOf(pattern, currentOffset);\r\n        if (index >= 0) {\r\n            this.bumpTo(index);\r\n            return true;\r\n        }\r\n        else {\r\n            this.bumpTo(this.message.length);\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Bump the parser to the target offset.\r\n     * If target offset is beyond the end of the input, bump the parser to the end of the input.\r\n     */\r\n    Parser.prototype.bumpTo = function (targetOffset) {\r\n        if (this.offset() > targetOffset) {\r\n            throw Error(\"targetOffset \" + targetOffset + \" must be greater than or equal to the current offset \" + this.offset());\r\n        }\r\n        targetOffset = Math.min(targetOffset, this.message.length);\r\n        while (true) {\r\n            var offset = this.offset();\r\n            if (offset === targetOffset) {\r\n                break;\r\n            }\r\n            if (offset > targetOffset) {\r\n                throw Error(\"targetOffset \" + targetOffset + \" is at invalid UTF-16 code unit boundary\");\r\n            }\r\n            this.bump();\r\n            if (this.isEOF()) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    /** advance the parser through all whitespace to the next non-whitespace code unit. */\r\n    Parser.prototype.bumpSpace = function () {\r\n        while (!this.isEOF() && _isWhiteSpace(this.char())) {\r\n            this.bump();\r\n        }\r\n    };\r\n    /**\r\n     * Peek at the *next* Unicode codepoint in the input without advancing the parser.\r\n     * If the input has been exhausted, then this returns null.\r\n     */\r\n    Parser.prototype.peek = function () {\r\n        if (this.isEOF()) {\r\n            return null;\r\n        }\r\n        var code = this.char();\r\n        var offset = this.offset();\r\n        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\r\n        return nextCode !== null && nextCode !== void 0 ? nextCode : null;\r\n    };\r\n    return Parser;\r\n}());\r\nexport { Parser };\r\n/**\r\n * This check if codepoint is alphabet (lower & uppercase)\r\n * @param codepoint\r\n * @returns\r\n */\r\nfunction _isAlpha(codepoint) {\r\n    return ((codepoint >= 97 && codepoint <= 122) ||\r\n        (codepoint >= 65 && codepoint <= 90));\r\n}\r\nfunction _isAlphaOrSlash(codepoint) {\r\n    return _isAlpha(codepoint) || codepoint === 47; /* '/' */\r\n}\r\n/** See `parseTag` function docs. */\r\nfunction _isPotentialElementNameChar(c) {\r\n    return (c === 45 /* '-' */ ||\r\n        c === 46 /* '.' */ ||\r\n        (c >= 48 && c <= 57) /* 0..9 */ ||\r\n        c === 95 /* '_' */ ||\r\n        (c >= 97 && c <= 122) /** a..z */ ||\r\n        (c >= 65 && c <= 90) /* A..Z */ ||\r\n        c == 0xb7 ||\r\n        (c >= 0xc0 && c <= 0xd6) ||\r\n        (c >= 0xd8 && c <= 0xf6) ||\r\n        (c >= 0xf8 && c <= 0x37d) ||\r\n        (c >= 0x37f && c <= 0x1fff) ||\r\n        (c >= 0x200c && c <= 0x200d) ||\r\n        (c >= 0x203f && c <= 0x2040) ||\r\n        (c >= 0x2070 && c <= 0x218f) ||\r\n        (c >= 0x2c00 && c <= 0x2fef) ||\r\n        (c >= 0x3001 && c <= 0xd7ff) ||\r\n        (c >= 0xf900 && c <= 0xfdcf) ||\r\n        (c >= 0xfdf0 && c <= 0xfffd) ||\r\n        (c >= 0x10000 && c <= 0xeffff));\r\n}\r\n/**\r\n * Code point equivalent of regex `\\p{White_Space}`.\r\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\r\nfunction _isWhiteSpace(c) {\r\n    return ((c >= 0x0009 && c <= 0x000d) ||\r\n        c === 0x0020 ||\r\n        c === 0x0085 ||\r\n        (c >= 0x200e && c <= 0x200f) ||\r\n        c === 0x2028 ||\r\n        c === 0x2029);\r\n}\r\n/**\r\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\r\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\r\n */\r\nfunction _isPatternSyntax(c) {\r\n    return ((c >= 0x0021 && c <= 0x0023) ||\r\n        c === 0x0024 ||\r\n        (c >= 0x0025 && c <= 0x0027) ||\r\n        c === 0x0028 ||\r\n        c === 0x0029 ||\r\n        c === 0x002a ||\r\n        c === 0x002b ||\r\n        c === 0x002c ||\r\n        c === 0x002d ||\r\n        (c >= 0x002e && c <= 0x002f) ||\r\n        (c >= 0x003a && c <= 0x003b) ||\r\n        (c >= 0x003c && c <= 0x003e) ||\r\n        (c >= 0x003f && c <= 0x0040) ||\r\n        c === 0x005b ||\r\n        c === 0x005c ||\r\n        c === 0x005d ||\r\n        c === 0x005e ||\r\n        c === 0x0060 ||\r\n        c === 0x007b ||\r\n        c === 0x007c ||\r\n        c === 0x007d ||\r\n        c === 0x007e ||\r\n        c === 0x00a1 ||\r\n        (c >= 0x00a2 && c <= 0x00a5) ||\r\n        c === 0x00a6 ||\r\n        c === 0x00a7 ||\r\n        c === 0x00a9 ||\r\n        c === 0x00ab ||\r\n        c === 0x00ac ||\r\n        c === 0x00ae ||\r\n        c === 0x00b0 ||\r\n        c === 0x00b1 ||\r\n        c === 0x00b6 ||\r\n        c === 0x00bb ||\r\n        c === 0x00bf ||\r\n        c === 0x00d7 ||\r\n        c === 0x00f7 ||\r\n        (c >= 0x2010 && c <= 0x2015) ||\r\n        (c >= 0x2016 && c <= 0x2017) ||\r\n        c === 0x2018 ||\r\n        c === 0x2019 ||\r\n        c === 0x201a ||\r\n        (c >= 0x201b && c <= 0x201c) ||\r\n        c === 0x201d ||\r\n        c === 0x201e ||\r\n        c === 0x201f ||\r\n        (c >= 0x2020 && c <= 0x2027) ||\r\n        (c >= 0x2030 && c <= 0x2038) ||\r\n        c === 0x2039 ||\r\n        c === 0x203a ||\r\n        (c >= 0x203b && c <= 0x203e) ||\r\n        (c >= 0x2041 && c <= 0x2043) ||\r\n        c === 0x2044 ||\r\n        c === 0x2045 ||\r\n        c === 0x2046 ||\r\n        (c >= 0x2047 && c <= 0x2051) ||\r\n        c === 0x2052 ||\r\n        c === 0x2053 ||\r\n        (c >= 0x2055 && c <= 0x205e) ||\r\n        (c >= 0x2190 && c <= 0x2194) ||\r\n        (c >= 0x2195 && c <= 0x2199) ||\r\n        (c >= 0x219a && c <= 0x219b) ||\r\n        (c >= 0x219c && c <= 0x219f) ||\r\n        c === 0x21a0 ||\r\n        (c >= 0x21a1 && c <= 0x21a2) ||\r\n        c === 0x21a3 ||\r\n        (c >= 0x21a4 && c <= 0x21a5) ||\r\n        c === 0x21a6 ||\r\n        (c >= 0x21a7 && c <= 0x21ad) ||\r\n        c === 0x21ae ||\r\n        (c >= 0x21af && c <= 0x21cd) ||\r\n        (c >= 0x21ce && c <= 0x21cf) ||\r\n        (c >= 0x21d0 && c <= 0x21d1) ||\r\n        c === 0x21d2 ||\r\n        c === 0x21d3 ||\r\n        c === 0x21d4 ||\r\n        (c >= 0x21d5 && c <= 0x21f3) ||\r\n        (c >= 0x21f4 && c <= 0x22ff) ||\r\n        (c >= 0x2300 && c <= 0x2307) ||\r\n        c === 0x2308 ||\r\n        c === 0x2309 ||\r\n        c === 0x230a ||\r\n        c === 0x230b ||\r\n        (c >= 0x230c && c <= 0x231f) ||\r\n        (c >= 0x2320 && c <= 0x2321) ||\r\n        (c >= 0x2322 && c <= 0x2328) ||\r\n        c === 0x2329 ||\r\n        c === 0x232a ||\r\n        (c >= 0x232b && c <= 0x237b) ||\r\n        c === 0x237c ||\r\n        (c >= 0x237d && c <= 0x239a) ||\r\n        (c >= 0x239b && c <= 0x23b3) ||\r\n        (c >= 0x23b4 && c <= 0x23db) ||\r\n        (c >= 0x23dc && c <= 0x23e1) ||\r\n        (c >= 0x23e2 && c <= 0x2426) ||\r\n        (c >= 0x2427 && c <= 0x243f) ||\r\n        (c >= 0x2440 && c <= 0x244a) ||\r\n        (c >= 0x244b && c <= 0x245f) ||\r\n        (c >= 0x2500 && c <= 0x25b6) ||\r\n        c === 0x25b7 ||\r\n        (c >= 0x25b8 && c <= 0x25c0) ||\r\n        c === 0x25c1 ||\r\n        (c >= 0x25c2 && c <= 0x25f7) ||\r\n        (c >= 0x25f8 && c <= 0x25ff) ||\r\n        (c >= 0x2600 && c <= 0x266e) ||\r\n        c === 0x266f ||\r\n        (c >= 0x2670 && c <= 0x2767) ||\r\n        c === 0x2768 ||\r\n        c === 0x2769 ||\r\n        c === 0x276a ||\r\n        c === 0x276b ||\r\n        c === 0x276c ||\r\n        c === 0x276d ||\r\n        c === 0x276e ||\r\n        c === 0x276f ||\r\n        c === 0x2770 ||\r\n        c === 0x2771 ||\r\n        c === 0x2772 ||\r\n        c === 0x2773 ||\r\n        c === 0x2774 ||\r\n        c === 0x2775 ||\r\n        (c >= 0x2794 && c <= 0x27bf) ||\r\n        (c >= 0x27c0 && c <= 0x27c4) ||\r\n        c === 0x27c5 ||\r\n        c === 0x27c6 ||\r\n        (c >= 0x27c7 && c <= 0x27e5) ||\r\n        c === 0x27e6 ||\r\n        c === 0x27e7 ||\r\n        c === 0x27e8 ||\r\n        c === 0x27e9 ||\r\n        c === 0x27ea ||\r\n        c === 0x27eb ||\r\n        c === 0x27ec ||\r\n        c === 0x27ed ||\r\n        c === 0x27ee ||\r\n        c === 0x27ef ||\r\n        (c >= 0x27f0 && c <= 0x27ff) ||\r\n        (c >= 0x2800 && c <= 0x28ff) ||\r\n        (c >= 0x2900 && c <= 0x2982) ||\r\n        c === 0x2983 ||\r\n        c === 0x2984 ||\r\n        c === 0x2985 ||\r\n        c === 0x2986 ||\r\n        c === 0x2987 ||\r\n        c === 0x2988 ||\r\n        c === 0x2989 ||\r\n        c === 0x298a ||\r\n        c === 0x298b ||\r\n        c === 0x298c ||\r\n        c === 0x298d ||\r\n        c === 0x298e ||\r\n        c === 0x298f ||\r\n        c === 0x2990 ||\r\n        c === 0x2991 ||\r\n        c === 0x2992 ||\r\n        c === 0x2993 ||\r\n        c === 0x2994 ||\r\n        c === 0x2995 ||\r\n        c === 0x2996 ||\r\n        c === 0x2997 ||\r\n        c === 0x2998 ||\r\n        (c >= 0x2999 && c <= 0x29d7) ||\r\n        c === 0x29d8 ||\r\n        c === 0x29d9 ||\r\n        c === 0x29da ||\r\n        c === 0x29db ||\r\n        (c >= 0x29dc && c <= 0x29fb) ||\r\n        c === 0x29fc ||\r\n        c === 0x29fd ||\r\n        (c >= 0x29fe && c <= 0x2aff) ||\r\n        (c >= 0x2b00 && c <= 0x2b2f) ||\r\n        (c >= 0x2b30 && c <= 0x2b44) ||\r\n        (c >= 0x2b45 && c <= 0x2b46) ||\r\n        (c >= 0x2b47 && c <= 0x2b4c) ||\r\n        (c >= 0x2b4d && c <= 0x2b73) ||\r\n        (c >= 0x2b74 && c <= 0x2b75) ||\r\n        (c >= 0x2b76 && c <= 0x2b95) ||\r\n        c === 0x2b96 ||\r\n        (c >= 0x2b97 && c <= 0x2bff) ||\r\n        (c >= 0x2e00 && c <= 0x2e01) ||\r\n        c === 0x2e02 ||\r\n        c === 0x2e03 ||\r\n        c === 0x2e04 ||\r\n        c === 0x2e05 ||\r\n        (c >= 0x2e06 && c <= 0x2e08) ||\r\n        c === 0x2e09 ||\r\n        c === 0x2e0a ||\r\n        c === 0x2e0b ||\r\n        c === 0x2e0c ||\r\n        c === 0x2e0d ||\r\n        (c >= 0x2e0e && c <= 0x2e16) ||\r\n        c === 0x2e17 ||\r\n        (c >= 0x2e18 && c <= 0x2e19) ||\r\n        c === 0x2e1a ||\r\n        c === 0x2e1b ||\r\n        c === 0x2e1c ||\r\n        c === 0x2e1d ||\r\n        (c >= 0x2e1e && c <= 0x2e1f) ||\r\n        c === 0x2e20 ||\r\n        c === 0x2e21 ||\r\n        c === 0x2e22 ||\r\n        c === 0x2e23 ||\r\n        c === 0x2e24 ||\r\n        c === 0x2e25 ||\r\n        c === 0x2e26 ||\r\n        c === 0x2e27 ||\r\n        c === 0x2e28 ||\r\n        c === 0x2e29 ||\r\n        (c >= 0x2e2a && c <= 0x2e2e) ||\r\n        c === 0x2e2f ||\r\n        (c >= 0x2e30 && c <= 0x2e39) ||\r\n        (c >= 0x2e3a && c <= 0x2e3b) ||\r\n        (c >= 0x2e3c && c <= 0x2e3f) ||\r\n        c === 0x2e40 ||\r\n        c === 0x2e41 ||\r\n        c === 0x2e42 ||\r\n        (c >= 0x2e43 && c <= 0x2e4f) ||\r\n        (c >= 0x2e50 && c <= 0x2e51) ||\r\n        c === 0x2e52 ||\r\n        (c >= 0x2e53 && c <= 0x2e7f) ||\r\n        (c >= 0x3001 && c <= 0x3003) ||\r\n        c === 0x3008 ||\r\n        c === 0x3009 ||\r\n        c === 0x300a ||\r\n        c === 0x300b ||\r\n        c === 0x300c ||\r\n        c === 0x300d ||\r\n        c === 0x300e ||\r\n        c === 0x300f ||\r\n        c === 0x3010 ||\r\n        c === 0x3011 ||\r\n        (c >= 0x3012 && c <= 0x3013) ||\r\n        c === 0x3014 ||\r\n        c === 0x3015 ||\r\n        c === 0x3016 ||\r\n        c === 0x3017 ||\r\n        c === 0x3018 ||\r\n        c === 0x3019 ||\r\n        c === 0x301a ||\r\n        c === 0x301b ||\r\n        c === 0x301c ||\r\n        c === 0x301d ||\r\n        (c >= 0x301e && c <= 0x301f) ||\r\n        c === 0x3020 ||\r\n        c === 0x3030 ||\r\n        c === 0xfd3e ||\r\n        c === 0xfd3f ||\r\n        (c >= 0xfe45 && c <= 0xfe46));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}