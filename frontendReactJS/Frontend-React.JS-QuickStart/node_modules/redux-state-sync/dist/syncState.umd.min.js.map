{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///syncState.umd.min.js","webpack:///webpack/bootstrap 9c3871ca04170c3c6d6a","webpack:///./~/broadcast-channel/dist/es/util.js","webpack:///./~/broadcast-channel/dist/es/options.js","webpack:///./~/broadcast-channel/dist/es/oblivious-set.js","webpack:///./~/broadcast-channel/dist/es/index.js","webpack:///./src/syncState.js","webpack:///./~/broadcast-channel/dist/es/method-chooser.js","webpack:///./~/broadcast-channel/dist/es/methods/indexed-db.js","webpack:///./~/broadcast-channel/dist/es/methods/localstorage.js","webpack:///./~/broadcast-channel/dist/es/methods/native.js","webpack:///./~/broadcast-channel/dist/es/methods/simulate.js","webpack:///./~/process/browser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","process","isPromise","obj","then","sleep","time","Promise","res","setTimeout","randomInt","min","max","Math","floor","random","randomToken","length","text","possible","charAt","microSeconds","ms","Date","getTime","lastMs","additional","isNode","toString","fillOptionsWithDefaults","options","JSON","parse","stringify","webWorkerSupport","idb","ttl","fallbackInterval","localstorage","removeTimeout","node","useFastPath","now","ObliviousSet","_removeTooOldValues","olderThen","iterator","set","Symbol","next","timeMap","Set","Map","has","bind","add","clear","_post","broadcastChannel","type","msg","method","msgObj","data","_prepP","resolve","postMessage","_state","_prepareChannel","channel","maybePromise","create","__WEBPACK_IMPORTED_MODULE_0__util_js__","_hasMessageListeners","_addEL","message","internal","_addListenerObject","push","_startListening","_removeListenerObject","filter","_stopListening","_iL","listenerFn","forEach","fn","onMessage","__WEBPACK_IMPORTED_MODULE_1__method_chooser_js__","__WEBPACK_IMPORTED_MODULE_2__options_js__","BroadcastChannel","ENFORCED_OPTIONS","_onML","_befC","_pubkey","clearNodeFolder","enforceOptions","closed","Error","postInternal","onmessage","listenObj","addEventListener","removeEventListener","find","close","_this","awaitPrepare","all","map","s4","substring","guid","generateUuidForAction","action","stampedAction","$uuid","$wuid","WINDOW_STATE_SYNC_ID","isActionAllowed","_ref","predicate","blacklist","whitelist","allowed","Array","isArray","indexOf","isActionSynced","$isSync","createMessageListener","_ref2","dispatch","isSynced","tabs","RECEIVE_INIT_STATE","lastUuid","GET_INIT_STATE","SEND_INIT_STATE","receiveIniteState","payload","assign","sendIniteState","initStateWithPrevTab","withReduxStateSync","createReduxStateSync","createStateSyncMiddleware","undefined","_broadcastChannel","_broadcastChannel2","default","defaultConfig","broadcastChannelOption","prepareState","state","getIniteState","isMessageListenerCreated","config","arguments","_ref3","getState","e","console","error","_ref4","appReducer","initState","_ref5","chooseMethod","__WEBPACK_IMPORTED_MODULE_3__methods_simulate_js__","ret","METHODS","chooseMethods","__WEBPACK_IMPORTED_MODULE_4__util__","useMethod","canBeUsed","__WEBPACK_IMPORTED_MODULE_0__methods_native_js__","__WEBPACK_IMPORTED_MODULE_1__methods_indexed_db_js__","__WEBPACK_IMPORTED_MODULE_2__methods_localstorage_js__","NodeMethod","getIdb","indexedDB","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","createDatabase","channelName","IndexedDB","dbName","DB_PREFIX","openRequest","open","onupgradeneeded","ev","target","result","createObjectStore","OBJECT_STORE_ID","keyPath","autoIncrement","rej","onerror","onsuccess","writeMessage","db","readerUuid","messageJson","writeObject","uuid","transaction","oncomplete","objectStore","getMessagesHigherThen","lastCursorId","keyRangeValue","IDBKeyRange","bound","Infinity","openCursor","cursor","removeMessageById","id","request","getOldMessages","msgObk","cleanOldMessages","tooOld","__WEBPACK_IMPORTED_MODULE_2__options__","eMIs","__WEBPACK_IMPORTED_MODULE_1__oblivious_set__","writeBlockPromise","messagesCallback","readQueuePromises","_readLoop","readNewMessages","_filterMessage","messagesCallbackTime","newerMessages","sort","msgObjA","msgObjB","channelState","averageResponseTime","getLocalStorage","localStorage","storageKey","KEY_PREFIX","__WEBPACK_IMPORTED_MODULE_2__util__","key","writeObj","token","setItem","document","createEvent","initEvent","newValue","dispatchEvent","addStorageEventListener","listener","removeStorageEventListener","__WEBPACK_IMPORTED_MODULE_1__options__","__WEBPACK_IMPORTED_MODULE_0__oblivious_set__","ls","removeItem","bc","subFns","__WEBPACK_IMPORTED_MODULE_0__util__","SIMULATE_CHANNELS","from","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"syncState.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"reduxStateSync\"] = factory();\n\telse\n\t\troot[\"reduxStateSync\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"reduxStateSync\"] = factory();\n\telse\n\t\troot[\"reduxStateSync\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (immutable) */ __webpack_exports__[\"a\"] = isPromise;\n/* harmony export (immutable) */ __webpack_exports__[\"d\"] = sleep;\n/* harmony export (immutable) */ __webpack_exports__[\"f\"] = randomInt;\n/* harmony export (immutable) */ __webpack_exports__[\"e\"] = randomToken;\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = microSeconds;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return isNode; });\n/**\n * returns true if the given object is a promise\n */\nfunction isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction sleep(time) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(res, time);\n  });\n}\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/1349426/3443137\n */\n\nfunction randomToken(length) {\n  if (!length) length = 5;\n  var text = '';\n  var possible = 'abcdefghijklmnopqrstuvwxzy0123456789';\n\n  for (var i = 0; i < length; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n\n  return text;\n}\nvar lastMs = 0;\nvar additional = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\n\nfunction microSeconds() {\n  var ms = new Date().getTime();\n\n  if (ms === lastMs) {\n    additional++;\n    return ms * 1000 + additional;\n  } else {\n    lastMs = ms;\n    additional = 0;\n    return ms * 1000;\n  }\n}\n/**\n * copied from the 'detect-node' npm module\n * We cannot use the module directly because it causes problems with rollup\n * @link https://github.com/iliakan/detect-node/blob/master/index.js\n */\n\nvar isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(10)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = fillOptionsWithDefaults;\nfunction fillOptionsWithDefaults(options) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options)); // main\n\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db\n\n  if (!options.idb) options.idb = {}; //  after this time the messages get deleted\n\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; // localstorage\n\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // node\n\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n * @constructor\n */\nvar ObliviousSet = function ObliviousSet(ttl) {\n  var set = new Set();\n  var timeMap = new Map();\n  this.has = set.has.bind(set);\n\n  this.add = function (value) {\n    timeMap.set(value, now());\n    set.add(value);\n\n    _removeTooOldValues();\n  };\n\n  this.clear = function () {\n    set.clear();\n    timeMap.clear();\n  };\n\n  function _removeTooOldValues() {\n    var olderThen = now() - ttl;\n    var iterator = set[Symbol.iterator]();\n\n    while (true) {\n      var value = iterator.next().value;\n      if (!value) return; // no more elements\n\n      var time = timeMap.get(value);\n\n      if (time < olderThen) {\n        timeMap[\"delete\"](value);\n        set[\"delete\"](value);\n      } else {\n        // we reached a value that is not old enough\n        return;\n      }\n    }\n  }\n};\n\nfunction now() {\n  return new Date().getTime();\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ObliviousSet);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__method_chooser_js__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__options_js__ = __webpack_require__(1);\n\n\n\n\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__options_js__[\"a\" /* fillOptionsWithDefaults */])(options);\n  this.method = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__method_chooser_js__[\"a\" /* chooseMethod */])(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nBroadcastChannel.clearNodeFolder = function (options) {\n  options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__options_js__[\"a\" /* fillOptionsWithDefaults */])(options);\n  var method = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__method_chooser_js__[\"a\" /* chooseMethod */])(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return Promise.resolve(false);\n  }\n};\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\n\nvar ENFORCED_OPTIONS;\n\nBroadcastChannel.enforceOptions = function (options) {\n  ENFORCED_OPTIONS = options;\n}; // PROTOTYPE\n\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) return;\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare.then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  }\n\n};\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n  return awaitPrepare.then(function () {\n    return broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_js__[\"a\" /* isPromise */])(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (obj) {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (BroadcastChannel);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initStateWithPrevTab = exports.withReduxStateSync = exports.createReduxStateSync = exports.createStateSyncMiddleware = undefined;\nexports.generateUuidForAction = generateUuidForAction;\nexports.isActionAllowed = isActionAllowed;\nexports.isActionSynced = isActionSynced;\nexports.createMessageListener = createMessageListener;\n\nvar _broadcastChannel = __webpack_require__(3);\n\nvar _broadcastChannel2 = _interopRequireDefault(_broadcastChannel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar lastUuid = 0; /* eslint-env browser */\n\nvar GET_INIT_STATE = '&_GET_INIT_STATE';\nvar SEND_INIT_STATE = '&_SEND_INIT_STATE';\nvar RECEIVE_INIT_STATE = '&_RECEIVE_INIT_STATE';\n\nvar defaultConfig = {\n  channel: 'redux_state_sync',\n  predicate: null,\n  blacklist: [],\n  whitelist: [],\n  broadcastChannelOption: null,\n  prepareState: function prepareState(state) {\n    return state;\n  }\n};\n\nvar getIniteState = function getIniteState() {\n  return { type: GET_INIT_STATE };\n};\nvar sendIniteState = function sendIniteState() {\n  return { type: SEND_INIT_STATE };\n};\nvar receiveIniteState = function receiveIniteState(state) {\n  return { type: RECEIVE_INIT_STATE, payload: state };\n};\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n}\n\nfunction guid() {\n  return '' + s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\n// generate current window unique id\nvar WINDOW_STATE_SYNC_ID = guid();\n// if the message receiver is already created\nvar isMessageListenerCreated = false;\n// export for test\nfunction generateUuidForAction(action) {\n  var stampedAction = action;\n  stampedAction.$uuid = guid();\n  stampedAction.$wuid = WINDOW_STATE_SYNC_ID;\n  return stampedAction;\n}\n// export for test\nfunction isActionAllowed(_ref) {\n  var predicate = _ref.predicate,\n      blacklist = _ref.blacklist,\n      whitelist = _ref.whitelist;\n\n  var allowed = function allowed() {\n    return true;\n  };\n\n  if (predicate && typeof predicate === 'function') {\n    allowed = predicate;\n  } else if (Array.isArray(blacklist)) {\n    allowed = function allowed(type) {\n      return blacklist.indexOf(type) < 0;\n    };\n  } else if (Array.isArray(whitelist)) {\n    allowed = function allowed(type) {\n      return whitelist.indexOf(type) >= 0;\n    };\n  }\n  return allowed;\n}\n// export for test\nfunction isActionSynced(action) {\n  return !!action.$isSync;\n}\n// export for test\nfunction createMessageListener(_ref2) {\n  var channel = _ref2.channel,\n      dispatch = _ref2.dispatch,\n      allowed = _ref2.allowed;\n\n  var isSynced = false;\n  var tabs = {};\n  var messageChannel = channel;\n  messageChannel.onmessage = function (stampedAction) {\n    // Ignore if this action is triggered by this window\n    if (stampedAction.$wuid === WINDOW_STATE_SYNC_ID) {\n      return;\n    }\n    // IE bug https://stackoverflow.com/questions/18265556/why-does-internet-explorer-fire-the-window-storage-event-on-the-window-that-st\n    if (stampedAction.type === RECEIVE_INIT_STATE) {\n      return;\n    }\n    // ignore other values that saved to localstorage.\n    if (stampedAction.$uuid && stampedAction.$uuid !== lastUuid) {\n      if (stampedAction.type === GET_INIT_STATE && !tabs[stampedAction.$wuid]) {\n        tabs[stampedAction.$wuid] = true;\n        dispatch(sendIniteState());\n      } else if (stampedAction.type === SEND_INIT_STATE && !tabs[stampedAction.$wuid]) {\n        if (!isSynced) {\n          isSynced = true;\n          dispatch(receiveIniteState(stampedAction.payload));\n        }\n        return;\n      } else if (allowed(stampedAction.type)) {\n        lastUuid = stampedAction.$uuid;\n        dispatch(Object.assign(stampedAction, {\n          $isSync: true\n        }));\n      }\n    }\n  };\n}\n\nvar createStateSyncMiddleware = exports.createStateSyncMiddleware = function createStateSyncMiddleware() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;\n\n  var allowed = isActionAllowed(config);\n  var channel = new _broadcastChannel2.default(config.channel, config.broadcastChannelOption);\n  var prepareState = config.prepareState || defaultConfig.prepareState;\n\n  return function (_ref3) {\n    var getState = _ref3.getState,\n        dispatch = _ref3.dispatch;\n    return function (next) {\n      return function (action) {\n        // create message receiver\n        if (!isMessageListenerCreated) {\n          isMessageListenerCreated = true;\n          createMessageListener({ channel: channel, dispatch: dispatch, allowed: allowed });\n        }\n        // post messages\n        if (action && !action.$uuid) {\n          var stampedAction = generateUuidForAction(action);\n          lastUuid = stampedAction.$uuid;\n          try {\n            if (action.type === SEND_INIT_STATE) {\n              if (getState()) {\n                stampedAction.payload = prepareState(getState());\n                channel.postMessage(stampedAction);\n              }\n              return next(action);\n            }\n            if (allowed(stampedAction.type) || action.type === GET_INIT_STATE) {\n              channel.postMessage(stampedAction);\n            }\n          } catch (e) {\n            console.error(\"Your browser doesn't support cross tab communication\");\n          }\n        }\n        return next(Object.assign(action, {\n          $isSync: typeof action.$isSync === 'undefined' ? false : action.$isSync\n        }));\n      };\n    };\n  };\n};\n\nvar createReduxStateSync = exports.createReduxStateSync = function createReduxStateSync(_ref4) {\n  var prepareState = _ref4.prepareState;\n  return function (appReducer) {\n    return function (state, action) {\n      var initState = state;\n      if (action.type === RECEIVE_INIT_STATE) {\n        initState = prepareState(action.payload);\n      }\n      return appReducer(initState, action);\n    };\n  };\n};\n\n// init state with other tab's state\nvar withReduxStateSync = exports.withReduxStateSync = createReduxStateSync({\n  prepareState: function prepareState(state) {\n    return state;\n  }\n});\n\nvar initStateWithPrevTab = exports.initStateWithPrevTab = function initStateWithPrevTab(_ref5) {\n  var dispatch = _ref5.dispatch;\n\n  dispatch(getIniteState());\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = chooseMethod;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__methods_native_js__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__methods_indexed_db_js__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__methods_localstorage_js__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__methods_simulate_js__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util__ = __webpack_require__(0);\n\n\n\n\n // order is important\n\nvar METHODS = [__WEBPACK_IMPORTED_MODULE_0__methods_native_js__[\"a\" /* default */], // fastest\n__WEBPACK_IMPORTED_MODULE_1__methods_indexed_db_js__[\"a\" /* default */], __WEBPACK_IMPORTED_MODULE_2__methods_localstorage_js__[\"a\" /* default */]];\n/**\n * The NodeMethod is loaded lazy\n * so it will not get bundled in browser-builds\n */\n\nif (__WEBPACK_IMPORTED_MODULE_4__util__[\"b\" /* isNode */]) {\n  /**\n   * we use the non-transpiled code for nodejs\n   * because it runs faster\n   */\n  var NodeMethod = __webpack_require__(11);\n  /**\n   * this will be false for webpackbuilds\n   * which will shim the node-method with an empty object {}\n   */\n\n\n  if (typeof NodeMethod.canBeUsed === 'function') {\n    METHODS.push(NodeMethod);\n  }\n}\n\nfunction chooseMethod(options) {\n  // directly chosen\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return __WEBPACK_IMPORTED_MODULE_3__methods_simulate_js__[\"a\" /* default */];\n    }\n\n    var ret = METHODS.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */\n\n\n  var chooseMethods = METHODS;\n\n  if (!options.webWorkerSupport && !__WEBPACK_IMPORTED_MODULE_4__util__[\"b\" /* isNode */]) {\n    chooseMethods = METHODS.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) throw new Error('No useable methode found:' + JSON.stringify(METHODS.map(function (m) {\n    return m.type;\n  })));else return useMethod;\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export microSeconds */\n/* unused harmony export type */\n/* unused harmony export getIdb */\n/* unused harmony export createDatabase */\n/* unused harmony export writeMessage */\n/* unused harmony export getAllMessages */\n/* unused harmony export getMessagesHigherThen */\n/* unused harmony export removeMessageById */\n/* unused harmony export getOldMessages */\n/* unused harmony export cleanOldMessages */\n/* unused harmony export create */\n/* unused harmony export close */\n/* unused harmony export postMessage */\n/* unused harmony export onMessage */\n/* unused harmony export canBeUsed */\n/* unused harmony export averageResponseTime */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__oblivious_set__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__options__ = __webpack_require__(1);\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n */\n\nvar microSeconds = __WEBPACK_IMPORTED_MODULE_0__util_js__[\"c\" /* microSeconds */];\n\n\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\nvar type = 'idb';\nfunction getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n  if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n  if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  return false;\n}\nfunction createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  var openRequest = IndexedDB.open(dbName, 1);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */\n\nfunction writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\n  return new Promise(function (res, rej) {\n    transaction.oncomplete = function () {\n      return res();\n    };\n\n    transaction.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n  });\n}\nfunction getAllMessages(db) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction getMessagesHigherThen(db, lastCursorId) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n  return new Promise(function (res) {\n    objectStore.openCursor(keyRangeValue).onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value);\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction removeMessageById(db, id) {\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\n  return new Promise(function (res) {\n    request.onsuccess = function () {\n      return res();\n    };\n  });\n}\nfunction getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return Promise.all(tooOld.map(function (msgObj) {\n      return removeMessageById(db, msgObj.id);\n    }));\n  });\n}\nfunction create(channelName, options) {\n  options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__options__[\"a\" /* fillOptionsWithDefaults */])(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_js__[\"e\" /* randomToken */])(10),\n\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new __WEBPACK_IMPORTED_MODULE_1__oblivious_set__[\"a\" /* default */](options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: Promise.resolve(),\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  return readNewMessages(state).then(function () {\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_js__[\"d\" /* sleep */])(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\n * reads all new messages from the database and emits them\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return Promise.resolve(); // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return Promise.resolve();\n  return getMessagesHigherThen(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */\n    .filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return Promise.resolve();\n  });\n}\n\nfunction close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nfunction postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__util_js__[\"f\" /* randomInt */])(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nfunction canBeUsed() {\n  if (__WEBPACK_IMPORTED_MODULE_0__util_js__[\"b\" /* isNode */]) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nfunction averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n});\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export microSeconds */\n/* unused harmony export type */\n/* unused harmony export getLocalStorage */\n/* unused harmony export storageKey */\n/* unused harmony export postMessage */\n/* unused harmony export addStorageEventListener */\n/* unused harmony export removeStorageEventListener */\n/* unused harmony export create */\n/* unused harmony export close */\n/* unused harmony export onMessage */\n/* unused harmony export canBeUsed */\n/* unused harmony export averageResponseTime */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__oblivious_set__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__options__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util__ = __webpack_require__(0);\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\n\n\nvar microSeconds = __WEBPACK_IMPORTED_MODULE_2__util__[\"c\" /* microSeconds */];\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nvar type = 'localstorage';\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\n\nfunction getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {// New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n\n  return localStorage;\n}\nfunction storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\n\nfunction postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__[\"d\" /* sleep */])().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__[\"e\" /* randomToken */])(10),\n        time: new Date().getTime(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nfunction addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n\n  window.addEventListener('storage', listener);\n  return listener;\n}\nfunction removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nfunction create(channelName, options) {\n  options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__options__[\"a\" /* fillOptionsWithDefaults */])(options);\n\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n\n  var uuid = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util__[\"e\" /* randomToken */])(10);\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n\n  var eMIs = new __WEBPACK_IMPORTED_MODULE_0__oblivious_set__[\"a\" /* default */](options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n\n  };\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n\n    if (msgObj.uuid === uuid) return; // own message\n\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nfunction close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  if (__WEBPACK_IMPORTED_MODULE_2__util__[\"b\" /* isNode */]) return false;\n  var ls = getLocalStorage();\n  if (!ls) return false;\n\n  try {\n    var key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n\n  return true;\n}\nfunction averageResponseTime() {\n  return 120;\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n});\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export microSeconds */\n/* unused harmony export type */\n/* unused harmony export create */\n/* unused harmony export close */\n/* unused harmony export postMessage */\n/* unused harmony export onMessage */\n/* unused harmony export canBeUsed */\n/* unused harmony export averageResponseTime */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(0);\n\nvar microSeconds = __WEBPACK_IMPORTED_MODULE_0__util__[\"c\" /* microSeconds */];\nvar type = 'native';\nfunction create(channelName) {\n  var state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n\n  };\n\n  state.bc.onmessage = function (msg) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n\n  return state;\n}\nfunction close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nfunction postMessage(channelState, messageJson) {\n  channelState.bc.postMessage(messageJson, false);\n}\nfunction onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (__WEBPACK_IMPORTED_MODULE_0__util__[\"b\" /* isNode */] && typeof window === 'undefined') return false;\n\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n\n    return true;\n  } else return false;\n}\nfunction averageResponseTime() {\n  return 150;\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n});\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export microSeconds */\n/* unused harmony export type */\n/* unused harmony export create */\n/* unused harmony export close */\n/* unused harmony export postMessage */\n/* unused harmony export onMessage */\n/* unused harmony export canBeUsed */\n/* unused harmony export averageResponseTime */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util__ = __webpack_require__(0);\n\nvar microSeconds = __WEBPACK_IMPORTED_MODULE_0__util__[\"c\" /* microSeconds */];\nvar type = 'simulate';\nvar SIMULATE_CHANNELS = new Set();\nfunction create(channelName) {\n  var state = {\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nfunction close(channelState) {\n  SIMULATE_CHANNELS[\"delete\"](channelState);\n}\nfunction postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      var channelArray = Array.from(SIMULATE_CHANNELS);\n      channelArray.filter(function (channel) {\n        return channel.name === channelState.name;\n      }).filter(function (channel) {\n        return channel !== channelState;\n      }).filter(function (channel) {\n        return !!channel.messagesCallback;\n      }).forEach(function (channel) {\n        return channel.messagesCallback(messageJson);\n      });\n      res();\n    }, 5);\n  });\n}\nfunction onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  return true;\n}\nfunction averageResponseTime() {\n  return 5;\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n});\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// syncState.umd.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9c3871ca04170c3c6d6a","/**\n * returns true if the given object is a promise\n */\nexport function isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function sleep(time) {\n  if (!time) time = 0;\n  return new Promise(function (res) {\n    return setTimeout(res, time);\n  });\n}\nexport function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/1349426/3443137\n */\n\nexport function randomToken(length) {\n  if (!length) length = 5;\n  var text = '';\n  var possible = 'abcdefghijklmnopqrstuvwxzy0123456789';\n\n  for (var i = 0; i < length; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n\n  return text;\n}\nvar lastMs = 0;\nvar additional = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\n\nexport function microSeconds() {\n  var ms = new Date().getTime();\n\n  if (ms === lastMs) {\n    additional++;\n    return ms * 1000 + additional;\n  } else {\n    lastMs = ms;\n    additional = 0;\n    return ms * 1000;\n  }\n}\n/**\n * copied from the 'detect-node' npm module\n * We cannot use the module directly because it causes problems with rollup\n * @link https://github.com/iliakan/detect-node/blob/master/index.js\n */\n\nexport var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/util.js\n// module id = 0\n// module chunks = 0","export function fillOptionsWithDefaults(options) {\n  if (!options) options = {};\n  options = JSON.parse(JSON.stringify(options)); // main\n\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db\n\n  if (!options.idb) options.idb = {}; //  after this time the messages get deleted\n\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; // localstorage\n\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // node\n\n  if (!options.node) options.node = {};\n  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;\n\n  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;\n  return options;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/options.js\n// module id = 1\n// module chunks = 0","/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n * @constructor\n */\nvar ObliviousSet = function ObliviousSet(ttl) {\n  var set = new Set();\n  var timeMap = new Map();\n  this.has = set.has.bind(set);\n\n  this.add = function (value) {\n    timeMap.set(value, now());\n    set.add(value);\n\n    _removeTooOldValues();\n  };\n\n  this.clear = function () {\n    set.clear();\n    timeMap.clear();\n  };\n\n  function _removeTooOldValues() {\n    var olderThen = now() - ttl;\n    var iterator = set[Symbol.iterator]();\n\n    while (true) {\n      var value = iterator.next().value;\n      if (!value) return; // no more elements\n\n      var time = timeMap.get(value);\n\n      if (time < olderThen) {\n        timeMap[\"delete\"](value);\n        set[\"delete\"](value);\n      } else {\n        // we reached a value that is not old enough\n        return;\n      }\n    }\n  }\n};\n\nfunction now() {\n  return new Date().getTime();\n}\n\nexport default ObliviousSet;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/oblivious-set.js\n// module id = 2\n// module chunks = 0","import { isPromise } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\n\nBroadcastChannel._pubkey = true;\n/**\n * clears the tmp-folder if is node\n * @return {Promise<boolean>} true if has run, false if not node\n */\n\nBroadcastChannel.clearNodeFolder = function (options) {\n  options = fillOptionsWithDefaults(options);\n  var method = chooseMethod(options);\n\n  if (method.type === 'node') {\n    return method.clearNodeFolder().then(function () {\n      return true;\n    });\n  } else {\n    return Promise.resolve(false);\n  }\n};\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\n\nvar ENFORCED_OPTIONS;\n\nBroadcastChannel.enforceOptions = function (options) {\n  ENFORCED_OPTIONS = options;\n}; // PROTOTYPE\n\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed');\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) return;\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : Promise.resolve();\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare.then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  }\n\n};\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : Promise.resolve();\n  return awaitPrepare.then(function () {\n    return broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (obj) {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\n\nexport default BroadcastChannel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/index.js\n// module id = 3\n// module chunks = 0","/* eslint-env browser */\nimport BroadcastChannel from 'broadcast-channel';\n\nlet lastUuid = 0;\nconst GET_INIT_STATE = '&_GET_INIT_STATE';\nconst SEND_INIT_STATE = '&_SEND_INIT_STATE';\nconst RECEIVE_INIT_STATE = '&_RECEIVE_INIT_STATE';\n\nconst defaultConfig = {\n  channel: 'redux_state_sync',\n  predicate: null,\n  blacklist: [],\n  whitelist: [],\n  broadcastChannelOption: null,\n  prepareState: state => state\n};\n\nconst getIniteState = () => ({ type: GET_INIT_STATE });\nconst sendIniteState = () => ({ type: SEND_INIT_STATE });\nconst receiveIniteState = state => ({ type: RECEIVE_INIT_STATE, payload: state });\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000)\n    .toString(16)\n    .substring(1);\n}\n\nfunction guid() {\n  return (\n    `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`\n  );\n}\n\n// generate current window unique id\nconst WINDOW_STATE_SYNC_ID = guid();\n// if the message receiver is already created\nlet isMessageListenerCreated = false;\n// export for test\nexport function generateUuidForAction(action) {\n  const stampedAction = action;\n  stampedAction.$uuid = guid();\n  stampedAction.$wuid = WINDOW_STATE_SYNC_ID;\n  return stampedAction;\n}\n// export for test\nexport function isActionAllowed({ predicate, blacklist, whitelist }) {\n  let allowed = () => true;\n\n  if (predicate && typeof predicate === 'function') {\n    allowed = predicate;\n  } else if (Array.isArray(blacklist)) {\n    allowed = type => blacklist.indexOf(type) < 0;\n  } else if (Array.isArray(whitelist)) {\n    allowed = type => whitelist.indexOf(type) >= 0;\n  }\n  return allowed;\n}\n// export for test\nexport function isActionSynced(action) {\n  return !!action.$isSync;\n}\n// export for test\nexport function createMessageListener({ channel, dispatch, allowed }) {\n  let isSynced = false;\n  const tabs = {};\n  const messageChannel = channel;\n  messageChannel.onmessage = (stampedAction) => {\n    // Ignore if this action is triggered by this window\n    if (stampedAction.$wuid === WINDOW_STATE_SYNC_ID) {\n      return;\n    }\n    // IE bug https://stackoverflow.com/questions/18265556/why-does-internet-explorer-fire-the-window-storage-event-on-the-window-that-st\n    if (stampedAction.type === RECEIVE_INIT_STATE) {\n      return;\n    }\n    // ignore other values that saved to localstorage.\n    if (stampedAction.$uuid && stampedAction.$uuid !== lastUuid) {\n      if (stampedAction.type === GET_INIT_STATE && !tabs[stampedAction.$wuid]) {\n        tabs[stampedAction.$wuid] = true;\n        dispatch(sendIniteState());\n      } else if (stampedAction.type === SEND_INIT_STATE && !tabs[stampedAction.$wuid]) {\n        if (!isSynced) {\n          isSynced = true;\n          dispatch(receiveIniteState(stampedAction.payload));\n        }\n        return;\n      } else if (allowed(stampedAction.type)) {\n        lastUuid = stampedAction.$uuid;\n        dispatch(Object.assign(stampedAction, {\n          $isSync: true,\n        }));\n      }\n    }\n  };\n}\n\nexport const createStateSyncMiddleware = (config = defaultConfig) => {\n  const allowed = isActionAllowed(config);\n  const channel = new BroadcastChannel(config.channel, config.broadcastChannelOption);\n  const prepareState = config.prepareState || defaultConfig.prepareState;\n\n  return ({ getState, dispatch }) => next => (action) => {\n    // create message receiver\n    if (!isMessageListenerCreated) {\n      isMessageListenerCreated = true;\n      createMessageListener({ channel, dispatch, allowed });\n    }\n    // post messages\n    if (action && !action.$uuid) {\n      const stampedAction = generateUuidForAction(action);\n      lastUuid = stampedAction.$uuid;\n      try {\n        if (action.type === SEND_INIT_STATE) {\n          if (getState()) {\n            stampedAction.payload = prepareState(getState());\n            channel.postMessage(stampedAction);\n          }\n          return next(action);\n        }\n        if (allowed(stampedAction.type) || action.type === GET_INIT_STATE) {\n          channel.postMessage(stampedAction);\n        }\n      } catch (e) {\n        console.error(\"Your browser doesn't support cross tab communication\");\n      }\n    }\n    return next(Object.assign(action, {\n      $isSync: typeof action.$isSync === 'undefined' ? false : action.$isSync,\n    }));\n  };\n};\n\nexport const createReduxStateSync = ({ prepareState }) => appReducer =>\n  ((state, action) => {\n    let initState = state;\n    if (action.type === RECEIVE_INIT_STATE) {\n      initState = prepareState(action.payload);\n    }\n    return appReducer(initState, action);\n  });\n\n// init state with other tab's state\nexport const withReduxStateSync = createReduxStateSync({\n  prepareState: state => state\n})\n\nexport const initStateWithPrevTab = ({ dispatch }) => {\n  dispatch(getIniteState());\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/syncState.js","import NativeMethod from './methods/native.js';\nimport IndexeDbMethod from './methods/indexed-db.js';\nimport LocalstorageMethod from './methods/localstorage.js';\nimport SimulateMethod from './methods/simulate.js';\nimport { isNode } from './util'; // order is important\n\nvar METHODS = [NativeMethod, // fastest\nIndexeDbMethod, LocalstorageMethod];\n/**\n * The NodeMethod is loaded lazy\n * so it will not get bundled in browser-builds\n */\n\nif (isNode) {\n  /**\n   * we use the non-transpiled code for nodejs\n   * because it runs faster\n   */\n  var NodeMethod = require('../../src/methods/' + // use this hack so that browserify and others\n  // do not import the node-method by default\n  // when bundling.\n  'node.js');\n  /**\n   * this will be false for webpackbuilds\n   * which will shim the node-method with an empty object {}\n   */\n\n\n  if (typeof NodeMethod.canBeUsed === 'function') {\n    METHODS.push(NodeMethod);\n  }\n}\n\nexport function chooseMethod(options) {\n  // directly chosen\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return SimulateMethod;\n    }\n\n    var ret = METHODS.find(function (m) {\n      return m.type === options.type;\n    });\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */\n\n\n  var chooseMethods = METHODS;\n\n  if (!options.webWorkerSupport && !isNode) {\n    chooseMethods = METHODS.filter(function (m) {\n      return m.type !== 'idb';\n    });\n  }\n\n  var useMethod = chooseMethods.find(function (method) {\n    return method.canBeUsed();\n  });\n  if (!useMethod) throw new Error('No useable methode found:' + JSON.stringify(METHODS.map(function (m) {\n    return m.type;\n  })));else return useMethod;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/method-chooser.js\n// module id = 5\n// module chunks = 0","/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n */\nimport { sleep, randomInt, randomToken, microSeconds as micro, isNode } from '../util.js';\nexport var microSeconds = micro;\nimport ObliviousSet from '../oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nvar DB_PREFIX = 'pubkey.broadcast-channel-0-';\nvar OBJECT_STORE_ID = 'messages';\nexport var type = 'idb';\nexport function getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n  if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n  if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  return false;\n}\nexport function createDatabase(channelName) {\n  var IndexedDB = getIdb(); // create table\n\n  var dbName = DB_PREFIX + channelName;\n  var openRequest = IndexedDB.open(dbName, 1);\n\n  openRequest.onupgradeneeded = function (ev) {\n    var db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n\n  var dbPromise = new Promise(function (res, rej) {\n    openRequest.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    openRequest.onsuccess = function () {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */\n\nexport function writeMessage(db, readerUuid, messageJson) {\n  var time = new Date().getTime();\n  var writeObject = {\n    uuid: readerUuid,\n    time: time,\n    data: messageJson\n  };\n  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');\n  return new Promise(function (res, rej) {\n    transaction.oncomplete = function () {\n      return res();\n    };\n\n    transaction.onerror = function (ev) {\n      return rej(ev);\n    };\n\n    var objectStore = transaction.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n  });\n}\nexport function getAllMessages(db) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function getMessagesHigherThen(db, lastCursorId) {\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n  return new Promise(function (res) {\n    objectStore.openCursor(keyRangeValue).onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        ret.push(cursor.value);\n        cursor[\"continue\"]();\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function removeMessageById(db, id) {\n  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)[\"delete\"](id);\n  return new Promise(function (res) {\n    request.onsuccess = function () {\n      return res();\n    };\n  });\n}\nexport function getOldMessages(db, ttl) {\n  var olderThen = new Date().getTime() - ttl;\n  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);\n  var ret = [];\n  return new Promise(function (res) {\n    objectStore.openCursor().onsuccess = function (ev) {\n      var cursor = ev.target.result;\n\n      if (cursor) {\n        var msgObk = cursor.value;\n\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk); //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n\n          cursor[\"continue\"]();\n        } else {\n          // no more old messages,\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nexport function cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(function (tooOld) {\n    return Promise.all(tooOld.map(function (msgObj) {\n      return removeMessageById(db, msgObj.id);\n    }));\n  });\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(function (db) {\n    var state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName: channelName,\n      options: options,\n      uuid: randomToken(10),\n\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: Promise.resolve(),\n      messagesCallback: null,\n      readQueuePromises: [],\n      db: db\n    };\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n\n    _readLoop(state);\n\n    return state;\n  });\n}\n\nfunction _readLoop(state) {\n  if (state.closed) return;\n  return readNewMessages(state).then(function () {\n    return sleep(state.options.idb.fallbackInterval);\n  }).then(function () {\n    return _readLoop(state);\n  });\n}\n\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n\n  return true;\n}\n/**\n * reads all new messages from the database and emits them\n */\n\n\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return Promise.resolve(); // if no one is listening, we do not need to scan for new messages\n\n  if (!state.messagesCallback) return Promise.resolve();\n  return getMessagesHigherThen(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */\n    .filter(function (msgObj) {\n      return !!msgObj;\n    }).map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    }); // sort by time\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return Promise.resolve();\n  });\n}\n\nexport function close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {\n    return writeMessage(channelState.db, channelState.uuid, messageJson);\n  }).then(function () {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nexport function averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/methods/indexed-db.js\n// module id = 6\n// module chunks = 0","/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\nimport ObliviousSet from '../oblivious-set';\nimport { fillOptionsWithDefaults } from '../options';\nimport { sleep, randomToken, microSeconds as micro, isNode } from '../util';\nexport var microSeconds = micro;\nvar KEY_PREFIX = 'pubkey.broadcastChannel-';\nexport var type = 'localstorage';\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\n\nexport function getLocalStorage() {\n  var localStorage;\n  if (typeof window === 'undefined') return null;\n\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {// New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n\n  return localStorage;\n}\nexport function storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\n\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    sleep().then(function () {\n      var key = storageKey(channelState.channelName);\n      var writeObj = {\n        token: randomToken(10),\n        time: new Date().getTime(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      var value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n\n      var ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nexport function addStorageEventListener(channelName, fn) {\n  var key = storageKey(channelName);\n\n  var listener = function listener(ev) {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n\n  window.addEventListener('storage', listener);\n  return listener;\n}\nexport function removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nexport function create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n\n  var uuid = randomToken(10);\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n\n  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  var state = {\n    channelName: channelName,\n    uuid: uuid,\n    eMIs: eMIs // emittedMessagesIds\n\n  };\n  state.listener = addStorageEventListener(channelName, function (msgObj) {\n    if (!state.messagesCallback) return; // no listener\n\n    if (msgObj.uuid === uuid) return; // own message\n\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nexport function close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nexport function onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  if (isNode) return false;\n  var ls = getLocalStorage();\n  if (!ls) return false;\n\n  try {\n    var key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n\n  return true;\n}\nexport function averageResponseTime() {\n  return 120;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/methods/localstorage.js\n// module id = 7\n// module chunks = 0","import { microSeconds as micro, isNode } from '../util';\nexport var microSeconds = micro;\nexport var type = 'native';\nexport function create(channelName) {\n  var state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n\n  };\n\n  state.bc.onmessage = function (msg) {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n\n  return state;\n}\nexport function close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nexport function postMessage(channelState, messageJson) {\n  channelState.bc.postMessage(messageJson, false);\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (isNode && typeof window === 'undefined') return false;\n\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n\n    return true;\n  } else return false;\n}\nexport function averageResponseTime() {\n  return 150;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/methods/native.js\n// module id = 8\n// module chunks = 0","import { microSeconds as micro } from '../util';\nexport var microSeconds = micro;\nexport var type = 'simulate';\nvar SIMULATE_CHANNELS = new Set();\nexport function create(channelName) {\n  var state = {\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nexport function close(channelState) {\n  SIMULATE_CHANNELS[\"delete\"](channelState);\n}\nexport function postMessage(channelState, messageJson) {\n  return new Promise(function (res) {\n    return setTimeout(function () {\n      var channelArray = Array.from(SIMULATE_CHANNELS);\n      channelArray.filter(function (channel) {\n        return channel.name === channelState.name;\n      }).filter(function (channel) {\n        return channel !== channelState;\n      }).filter(function (channel) {\n        return !!channel.messagesCallback;\n      }).forEach(function (channel) {\n        return channel.messagesCallback(messageJson);\n      });\n      res();\n    }, 5);\n  });\n}\nexport function onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nexport function canBeUsed() {\n  return true;\n}\nexport function averageResponseTime() {\n  return 5;\n}\nexport default {\n  create: create,\n  close: close,\n  onMessage: onMessage,\n  postMessage: postMessage,\n  canBeUsed: canBeUsed,\n  type: type,\n  averageResponseTime: averageResponseTime,\n  microSeconds: microSeconds\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/broadcast-channel/dist/es/methods/simulate.js\n// module id = 9\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 10\n// module chunks = 0"],"sourceRoot":""}